// Generated by Haxe 4.2.0-rc.1+cb30bd580
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringBuf
#include <StringBuf.h>
#endif
#ifndef INCLUDED_dsHelper_splitter_StringCodeIterator
#include <dsHelper/splitter/StringCodeIterator.h>
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_justPath_IPathContext
#include <justPath/IPathContext.h>
#endif
#ifndef INCLUDED_trilateral3_Trilateral
#include <trilateral3/Trilateral.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Contour
#include <trilateral3/drawing/Contour.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Pen
#include <trilateral3/drawing/Pen.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Sketch
#include <trilateral3/drawing/Sketch.h>
#endif
#ifndef INCLUDED_trilateral3_math__Algebra_Algebra_Fields_
#include <trilateral3/math/_Algebra/Algebra_Fields_.h>
#endif
#ifndef INCLUDED_trilateral3_matrix_MatrixDozen
#include <trilateral3/matrix/MatrixDozen.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_6351d8d914bc61da_14_new,"trilateral3.drawing.Sketch","new",0x720a6595,"trilateral3.drawing.Sketch.new","trilateral3/drawing/Sketch.hx",14,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_30_tracerLine,"trilateral3.drawing.Sketch","tracerLine",0x0f56c04c,"trilateral3.drawing.Sketch.tracerLine","trilateral3/drawing/Sketch.hx",30,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_32_fillOnlyLine,"trilateral3.drawing.Sketch","fillOnlyLine",0x8ad9d14e,"trilateral3.drawing.Sketch.fillOnlyLine","trilateral3/drawing/Sketch.hx",32,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_34_baseLine,"trilateral3.drawing.Sketch","baseLine",0xf4387350,"trilateral3.drawing.Sketch.baseLine","trilateral3/drawing/Sketch.hx",34,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_39_crudeLine,"trilateral3.drawing.Sketch","crudeLine",0x9b1c8e70,"trilateral3.drawing.Sketch.crudeLine","trilateral3/drawing/Sketch.hx",39,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_42_roundEndLine,"trilateral3.drawing.Sketch","roundEndLine",0xcb0a62ec,"trilateral3.drawing.Sketch.roundEndLine","trilateral3/drawing/Sketch.hx",42,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_45_mediumLine,"trilateral3.drawing.Sketch","mediumLine",0x40d82274,"trilateral3.drawing.Sketch.mediumLine","trilateral3/drawing/Sketch.hx",45,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_48_mediumOverlapLine,"trilateral3.drawing.Sketch","mediumOverlapLine",0x6ebb9c9b,"trilateral3.drawing.Sketch.mediumOverlapLine","trilateral3/drawing/Sketch.hx",48,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_51_fineLine,"trilateral3.drawing.Sketch","fineLine",0x25e523f9,"trilateral3.drawing.Sketch.fineLine","trilateral3/drawing/Sketch.hx",51,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_54_fineOverlapLine,"trilateral3.drawing.Sketch","fineOverlapLine",0xdef605b6,"trilateral3.drawing.Sketch.fineOverlapLine","trilateral3/drawing/Sketch.hx",54,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_90_reset,"trilateral3.drawing.Sketch","reset",0x23365644,"trilateral3.drawing.Sketch.reset","trilateral3/drawing/Sketch.hx",90,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_99_pointsNoEndOverlap,"trilateral3.drawing.Sketch","pointsNoEndOverlap",0x74eb1dbb,"trilateral3.drawing.Sketch.pointsNoEndOverlap","trilateral3/drawing/Sketch.hx",99,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_153_pointsRewound,"trilateral3.drawing.Sketch","pointsRewound",0x5e7f2bd2,"trilateral3.drawing.Sketch.pointsRewound","trilateral3/drawing/Sketch.hx",153,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_214_initDim,"trilateral3.drawing.Sketch","initDim",0x88e4d7cd,"trilateral3.drawing.Sketch.initDim","trilateral3/drawing/Sketch.hx",214,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_216_updateDim,"trilateral3.drawing.Sketch","updateDim",0xbb1f05b4,"trilateral3.drawing.Sketch.updateDim","trilateral3/drawing/Sketch.hx",216,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_223_moveTo,"trilateral3.drawing.Sketch","moveTo",0x7089acd7,"trilateral3.drawing.Sketch.moveTo","trilateral3/drawing/Sketch.hx",223,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_242_lastClock,"trilateral3.drawing.Sketch","lastClock",0xcd56228d,"trilateral3.drawing.Sketch.lastClock","trilateral3/drawing/Sketch.hx",242,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_251_getEdges,"trilateral3.drawing.Sketch","getEdges",0xc1eee7cb,"trilateral3.drawing.Sketch.getEdges","trilateral3/drawing/Sketch.hx",251,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_279_lineTo,"trilateral3.drawing.Sketch","lineTo",0x907d207a,"trilateral3.drawing.Sketch.lineTo","trilateral3/drawing/Sketch.hx",279,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_296_quadTo,"trilateral3.drawing.Sketch","quadTo",0x707c5c0d,"trilateral3.drawing.Sketch.quadTo","trilateral3/drawing/Sketch.hx",296,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_305_quadThru,"trilateral3.drawing.Sketch","quadThru",0xcd504d49,"trilateral3.drawing.Sketch.quadThru","trilateral3/drawing/Sketch.hx",305,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_311_curveTo,"trilateral3.drawing.Sketch","curveTo",0x8bea33bf,"trilateral3.drawing.Sketch.curveTo","trilateral3/drawing/Sketch.hx",311,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_319_plotCoord,"trilateral3.drawing.Sketch","plotCoord",0xe9ec83c9,"trilateral3.drawing.Sketch.plotCoord","trilateral3/drawing/Sketch.hx",319,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_334_aiString,"trilateral3.drawing.Sketch","aiString",0xf866fa84,"trilateral3.drawing.Sketch.aiString","trilateral3/drawing/Sketch.hx",334,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_84_create,"trilateral3.drawing.Sketch","create",0x1fec40e7,"trilateral3.drawing.Sketch.create","trilateral3/drawing/Sketch.hx",84,0x5aa78a39)
namespace trilateral3{
namespace drawing{

void Sketch_obj::__construct( ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_){
            		int endLine_ = __o_endLine_.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_6351d8d914bc61da_14_new)
HXLINE(  17)		this->width = ((Float)0.01);
HXLINE(  16)		this->y = ((Float)0.);
HXLINE(  15)		this->x = ((Float)0.);
HXLINE(  59)		this->contour =  ::trilateral3::drawing::Contour_obj::__alloc( HX_CTX ,pen_,endLine_);
HXLINE(  60)		this->pen = pen_;
HXLINE(  61)		this->endLine = endLine_;
HXLINE(  62)		this->sketchForm = sketchForm_;
HXLINE(  63)		switch((int)(sketchForm_)){
            			case (int)0: {
HXLINE(  64)				this->line = this->tracerLine_dyn();
            			}
            			break;
            			case (int)1: {
HXLINE(  65)				this->line = this->baseLine_dyn();
            			}
            			break;
            			case (int)2: {
HXLINE(  66)				this->line = this->crudeLine_dyn();
            			}
            			break;
            			case (int)3: {
HXLINE(  67)				this->line = this->fillOnlyLine_dyn();
            			}
            			break;
            			case (int)4: {
HXLINE(  68)				this->line = this->fineLine_dyn();
            			}
            			break;
            			case (int)5: {
HXLINE(  69)				this->line = this->fineOverlapLine_dyn();
            			}
            			break;
            			case (int)6: {
HXLINE(  70)				this->line = this->mediumLine_dyn();
            			}
            			break;
            			case (int)7: {
HXLINE(  71)				this->line = this->mediumOverlapLine_dyn();
            			}
            			break;
            			case (int)8: {
HXLINE(  72)				this->line = this->roundEndLine_dyn();
            			}
            			break;
            		}
HXLINE(  74)		this->points = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  75)		this->pointsClock = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  76)		this->pointsAnti = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  77)		this->points[0] = ::Array_obj< Float >::__new();
HXLINE(  78)		this->dim = ::Array_obj< ::Dynamic>::__new();
            	}

Dynamic Sketch_obj::__CreateEmpty() { return new Sketch_obj; }

void *Sketch_obj::_hx_vtable = 0;

Dynamic Sketch_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Sketch_obj > _hx_result = new Sketch_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Sketch_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x100e59ef;
}

static ::justPath::IPathContext_obj _hx_trilateral3_drawing_Sketch__hx_justPath_IPathContext= {
	( void (::hx::Object::*)(Float,Float))&::trilateral3::drawing::Sketch_obj::moveTo,
	( void (::hx::Object::*)(Float,Float))&::trilateral3::drawing::Sketch_obj::lineTo,
	( void (::hx::Object::*)(Float,Float,Float,Float))&::trilateral3::drawing::Sketch_obj::quadTo,
	( void (::hx::Object::*)(Float,Float,Float,Float,Float,Float))&::trilateral3::drawing::Sketch_obj::curveTo,
};

void *Sketch_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xed67b972: return &_hx_trilateral3_drawing_Sketch__hx_justPath_IPathContext;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void Sketch_obj::tracerLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_30_tracerLine)
HXDLIN(  30)		::haxe::Log_obj::trace(((((((((HX_("lineTo( ",47,6b,2a,8a) + this->x) + HX_(", ",74,26,00,00)) + this->y) + HX_(", ",74,26,00,00)) + x_) + HX_(", ",74,26,00,00)) + y_) + HX_(", width )",9b,2f,cd,98)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),30,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("tracerLine",e1,14,6f,0a)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,tracerLine,(void))

void Sketch_obj::fillOnlyLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_32_fillOnlyLine)
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fillOnlyLine,(void))

void Sketch_obj::baseLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_34_baseLine)
HXLINE(  35)		::haxe::Log_obj::trace(((((((((HX_("lineTo( ",47,6b,2a,8a) + this->x) + HX_(", ",74,26,00,00)) + this->y) + HX_(", ",74,26,00,00)) + x_) + HX_(", ",74,26,00,00)) + y_) + HX_(", width )",9b,2f,cd,98)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),30,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("tracerLine",e1,14,6f,0a)));
HXLINE(  36)		{
HXLINE(  36)			 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  36)			Float ax_ = this->x;
HXDLIN(  36)			Float ay_ = this->y;
HXDLIN(  36)			Float width_ = this->width;
HXDLIN(  36)			_this->ax = x_;
HXDLIN(  36)			_this->ay = y_;
HXDLIN(  36)			_this->bx = ax_;
HXDLIN(  36)			_this->by = ay_;
HXDLIN(  36)			_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  36)			_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  36)			_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  36)			{
HXLINE(  36)				{
HXLINE(  36)					_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  36)					if ((_this->theta > 0)) {
HXLINE(  36)						if ((_this->halfA < 0)) {
HXLINE(  36)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  36)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            						else {
HXLINE(  36)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  36)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            					}
            					else {
HXLINE(  36)						if ((_this->halfA > 0)) {
HXLINE(  36)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  36)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            						else {
HXLINE(  36)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  36)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            					}
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->dxPrev )) {
HXLINE(  36)					_this->dxOld = _this->dxPrev;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->dyPrev )) {
HXLINE(  36)					_this->dyOld = _this->dyPrev;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->exPrev )) {
HXLINE(  36)					_this->exOld = _this->exPrev;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->eyPrev )) {
HXLINE(  36)					_this->eyOld = _this->eyPrev;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->dx )) {
HXLINE(  36)					_this->dxPrev = _this->dx;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->dy )) {
HXLINE(  36)					_this->dyPrev = _this->dy;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->ex )) {
HXLINE(  36)					_this->exPrev = _this->ex;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->ey )) {
HXLINE(  36)					_this->eyPrev = _this->ey;
            				}
HXDLIN(  36)				_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  36)				_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  36)				_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  36)				_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            			}
HXDLIN(  36)			 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  36)			 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  36)			 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  36)			 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  36)			_this->ax = ax_;
HXDLIN(  36)			_this->ay = ay_;
HXDLIN(  36)			_this->bx = x_;
HXDLIN(  36)			_this->by = y_;
HXDLIN(  36)			{
HXLINE(  36)				{
HXLINE(  36)					_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  36)					if ((_this->theta > 0)) {
HXLINE(  36)						if ((_this->halfA < 0)) {
HXLINE(  36)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  36)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            						else {
HXLINE(  36)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  36)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            					}
            					else {
HXLINE(  36)						if ((_this->halfA > 0)) {
HXLINE(  36)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  36)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            						else {
HXLINE(  36)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  36)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            					}
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->dxPrev )) {
HXLINE(  36)					_this->dxOld = _this->dxPrev;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->dyPrev )) {
HXLINE(  36)					_this->dyOld = _this->dyPrev;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->exPrev )) {
HXLINE(  36)					_this->exOld = _this->exPrev;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->eyPrev )) {
HXLINE(  36)					_this->eyOld = _this->eyPrev;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->dx )) {
HXLINE(  36)					_this->dxPrev = _this->dx;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->dy )) {
HXLINE(  36)					_this->dyPrev = _this->dy;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->ex )) {
HXLINE(  36)					_this->exPrev = _this->ex;
            				}
HXDLIN(  36)				if (::hx::IsNotNull( _this->ey )) {
HXLINE(  36)					_this->eyPrev = _this->ey;
            				}
HXDLIN(  36)				_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  36)				_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  36)				_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  36)				_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            			}
HXDLIN(  36)			{
HXLINE(  36)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  36)				int color = -1;
HXDLIN(  36)				if ((color == -1)) {
HXLINE(  36)					color = _this1->currentColor;
            				}
HXDLIN(  36)				{
HXLINE(  36)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
HXDLIN(  36)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE(  36)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  36)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  36)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  36)			{
HXLINE(  36)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  36)				int color1 = -1;
HXDLIN(  36)				if ((color1 == -1)) {
HXLINE(  36)					color1 = _this2->currentColor;
            				}
HXDLIN(  36)				{
HXLINE(  36)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  36)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE(  36)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  36)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  36)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,baseLine,(void))

void Sketch_obj::crudeLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_39_crudeLine)
HXDLIN(  39)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  39)		Float ax_ = this->x;
HXDLIN(  39)		Float ay_ = this->y;
HXDLIN(  39)		Float width_ = this->width;
HXDLIN(  39)		_this->ax = x_;
HXDLIN(  39)		_this->ay = y_;
HXDLIN(  39)		_this->bx = ax_;
HXDLIN(  39)		_this->by = ay_;
HXDLIN(  39)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  39)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  39)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  39)		{
HXDLIN(  39)			{
HXDLIN(  39)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  39)				if ((_this->theta > 0)) {
HXDLIN(  39)					if ((_this->halfA < 0)) {
HXDLIN(  39)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  39)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  39)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  39)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  39)					if ((_this->halfA > 0)) {
HXDLIN(  39)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  39)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  39)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  39)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  39)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  39)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  39)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  39)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  39)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  39)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  39)				_this->exPrev = _this->ex;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  39)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  39)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  39)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  39)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  39)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  39)		 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  39)		 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  39)		 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  39)		 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  39)		_this->ax = ax_;
HXDLIN(  39)		_this->ay = ay_;
HXDLIN(  39)		_this->bx = x_;
HXDLIN(  39)		_this->by = y_;
HXDLIN(  39)		{
HXDLIN(  39)			{
HXDLIN(  39)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  39)				if ((_this->theta > 0)) {
HXDLIN(  39)					if ((_this->halfA < 0)) {
HXDLIN(  39)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  39)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  39)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  39)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  39)					if ((_this->halfA > 0)) {
HXDLIN(  39)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  39)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  39)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  39)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  39)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  39)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  39)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  39)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  39)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  39)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  39)				_this->exPrev = _this->ex;
            			}
HXDLIN(  39)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  39)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  39)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  39)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  39)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  39)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  39)		{
HXDLIN(  39)			 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  39)			int color = -1;
HXDLIN(  39)			if ((color == -1)) {
HXDLIN(  39)				color = _this1->currentColor;
            			}
HXDLIN(  39)			{
HXDLIN(  39)				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
HXDLIN(  39)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  39)					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  39)				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  39)			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
HXDLIN(  39)		{
HXDLIN(  39)			 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  39)			int color1 = -1;
HXDLIN(  39)			if ((color1 == -1)) {
HXDLIN(  39)				color1 = _this2->currentColor;
            			}
HXDLIN(  39)			{
HXDLIN(  39)				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  39)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  39)					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  39)				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  39)			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,crudeLine,(void))

void Sketch_obj::roundEndLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_42_roundEndLine)
HXDLIN(  42)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  42)		Float ax_ = this->x;
HXDLIN(  42)		Float ay_ = this->y;
HXDLIN(  42)		Float width_ = this->width;
HXDLIN(  42)		 ::Dynamic endLineCurve = 3;
HXDLIN(  42)		if (::hx::IsNull( endLineCurve )) {
HXDLIN(  42)			endLineCurve = 0;
            		}
HXDLIN(  42)		_this->ax = x_;
HXDLIN(  42)		_this->ay = y_;
HXDLIN(  42)		_this->bx = ax_;
HXDLIN(  42)		_this->by = ay_;
HXDLIN(  42)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  42)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  42)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  42)		{
HXDLIN(  42)			{
HXDLIN(  42)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  42)				if ((_this->theta > 0)) {
HXDLIN(  42)					if ((_this->halfA < 0)) {
HXDLIN(  42)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  42)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  42)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  42)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  42)					if ((_this->halfA > 0)) {
HXDLIN(  42)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  42)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  42)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  42)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  42)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  42)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  42)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  42)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  42)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  42)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  42)				_this->exPrev = _this->ex;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  42)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  42)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  42)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  42)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  42)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  42)		 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  42)		 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  42)		 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  42)		 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  42)		_this->ax = ax_;
HXDLIN(  42)		_this->ay = ay_;
HXDLIN(  42)		_this->bx = x_;
HXDLIN(  42)		_this->by = y_;
HXDLIN(  42)		{
HXDLIN(  42)			{
HXDLIN(  42)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  42)				if ((_this->theta > 0)) {
HXDLIN(  42)					if ((_this->halfA < 0)) {
HXDLIN(  42)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  42)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  42)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  42)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  42)					if ((_this->halfA > 0)) {
HXDLIN(  42)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  42)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  42)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  42)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  42)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  42)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  42)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  42)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  42)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  42)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  42)				_this->exPrev = _this->ex;
            			}
HXDLIN(  42)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  42)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  42)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  42)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  42)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  42)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  42)		 ::Dynamic _hx_switch_0 = endLineCurve;
            		if (  (_hx_switch_0==0) ){
HXDLIN(  42)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==1) ){
HXDLIN(  42)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  42)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  42)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  42)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  42)			 ::Dynamic sides = 36;
HXDLIN(  42)			if (::hx::IsNull( sides )) {
HXDLIN(  42)				sides = 36;
            			}
HXDLIN(  42)			Float pi = ::Math_obj::PI;
HXDLIN(  42)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  42)			Float dif;
HXDLIN(  42)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  42)					Float f;
HXDLIN(  42)					bool f1;
HXDLIN(  42)					if ((beta >= 0)) {
HXDLIN(  42)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f1 = false;
            					}
HXDLIN(  42)					if (f1) {
HXDLIN(  42)						f = beta;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f = a;
            						}
            						else {
HXDLIN(  42)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this1 = f;
HXDLIN(  42)					Float za = this1;
HXDLIN(  42)					Float f2;
HXDLIN(  42)					bool f3;
HXDLIN(  42)					if ((gamma >= 0)) {
HXDLIN(  42)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f3 = false;
            					}
HXDLIN(  42)					if (f3) {
HXDLIN(  42)						f2 = gamma;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f2 = a;
            						}
            						else {
HXDLIN(  42)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this2 = f2;
HXDLIN(  42)					Float zb = this2;
HXDLIN(  42)					Float fa = za;
HXDLIN(  42)					Float fb = zb;
HXDLIN(  42)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)					bool clockwise = (fa < fb);
HXDLIN(  42)					Float dif1;
HXDLIN(  42)					if (clockwise) {
HXDLIN(  42)						dif1 = theta;
            					}
            					else {
HXDLIN(  42)						dif1 = -(theta);
            					}
HXDLIN(  42)					if ((dif1 > 0)) {
HXDLIN(  42)						dif = dif1;
            					}
            					else {
HXDLIN(  42)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  42)					Float f;
HXDLIN(  42)					bool f1;
HXDLIN(  42)					if ((beta >= 0)) {
HXDLIN(  42)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f1 = false;
            					}
HXDLIN(  42)					if (f1) {
HXDLIN(  42)						f = beta;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f = a;
            						}
            						else {
HXDLIN(  42)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this1 = f;
HXDLIN(  42)					Float za = this1;
HXDLIN(  42)					Float f2;
HXDLIN(  42)					bool f3;
HXDLIN(  42)					if ((gamma >= 0)) {
HXDLIN(  42)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f3 = false;
            					}
HXDLIN(  42)					if (f3) {
HXDLIN(  42)						f2 = gamma;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f2 = a;
            						}
            						else {
HXDLIN(  42)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this2 = f2;
HXDLIN(  42)					Float zb = this2;
HXDLIN(  42)					Float fa = za;
HXDLIN(  42)					Float fb = zb;
HXDLIN(  42)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)					bool clockwise = (fa < fb);
HXDLIN(  42)					Float dif1;
HXDLIN(  42)					if (clockwise) {
HXDLIN(  42)						dif1 = theta;
            					}
            					else {
HXDLIN(  42)						dif1 = -(theta);
            					}
HXDLIN(  42)					if ((dif1 < 0)) {
HXDLIN(  42)						dif = dif1;
            					}
            					else {
HXDLIN(  42)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  42)					Float f;
HXDLIN(  42)					bool f1;
HXDLIN(  42)					if ((beta >= 0)) {
HXDLIN(  42)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f1 = false;
            					}
HXDLIN(  42)					if (f1) {
HXDLIN(  42)						f = beta;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f = a;
            						}
            						else {
HXDLIN(  42)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this1 = f;
HXDLIN(  42)					Float za = this1;
HXDLIN(  42)					Float f2;
HXDLIN(  42)					bool f3;
HXDLIN(  42)					if ((gamma >= 0)) {
HXDLIN(  42)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f3 = false;
            					}
HXDLIN(  42)					if (f3) {
HXDLIN(  42)						f2 = gamma;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f2 = a;
            						}
            						else {
HXDLIN(  42)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this2 = f2;
HXDLIN(  42)					Float zb = this2;
HXDLIN(  42)					Float fa = za;
HXDLIN(  42)					Float fb = zb;
HXDLIN(  42)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  42)					bool clockwise = (fa < fb);
HXDLIN(  42)					Float dif1;
HXDLIN(  42)					if (clockwise) {
HXDLIN(  42)						dif1 = theta;
            					}
            					else {
HXDLIN(  42)						dif1 = -(theta);
            					}
HXDLIN(  42)					if (smallest) {
HXDLIN(  42)						dif = dif1;
            					}
            					else {
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  42)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  42)					Float f;
HXDLIN(  42)					bool f1;
HXDLIN(  42)					if ((beta >= 0)) {
HXDLIN(  42)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f1 = false;
            					}
HXDLIN(  42)					if (f1) {
HXDLIN(  42)						f = beta;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f = a;
            						}
            						else {
HXDLIN(  42)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this1 = f;
HXDLIN(  42)					Float za = this1;
HXDLIN(  42)					Float f2;
HXDLIN(  42)					bool f3;
HXDLIN(  42)					if ((gamma >= 0)) {
HXDLIN(  42)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f3 = false;
            					}
HXDLIN(  42)					if (f3) {
HXDLIN(  42)						f2 = gamma;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f2 = a;
            						}
            						else {
HXDLIN(  42)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this2 = f2;
HXDLIN(  42)					Float zb = this2;
HXDLIN(  42)					Float fa = za;
HXDLIN(  42)					Float fb = zb;
HXDLIN(  42)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  42)					bool clockwise = (fa < fb);
HXDLIN(  42)					Float dif1;
HXDLIN(  42)					if (clockwise) {
HXDLIN(  42)						dif1 = theta;
            					}
            					else {
HXDLIN(  42)						dif1 = -(theta);
            					}
HXDLIN(  42)					if (largest) {
HXDLIN(  42)						dif = dif1;
            					}
            					else {
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  42)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  42)			bool positive = (dif >= 0);
HXDLIN(  42)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  42)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  42)			Float angle = beta;
HXDLIN(  42)			Float cx;
HXDLIN(  42)			Float cy;
HXDLIN(  42)			Float bx = ( (Float)(0) );
HXDLIN(  42)			Float by = ( (Float)(0) );
HXDLIN(  42)			{
HXDLIN(  42)				int _g = 0;
HXDLIN(  42)				int _g1 = (totalSteps + 1);
HXDLIN(  42)				while((_g < _g1)){
HXDLIN(  42)					_g = (_g + 1);
HXDLIN(  42)					int i = (_g - 1);
HXDLIN(  42)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  42)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  42)					if ((i != 0)) {
HXDLIN(  42)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  42)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  42)						if (::hx::IsNotNull( m )) {
HXDLIN(  42)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  42)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  42)					angle = (angle + step1);
HXDLIN(  42)					bx = cx;
HXDLIN(  42)					by = cy;
            				}
            			}
HXDLIN(  42)			int len = totalSteps;
HXDLIN(  42)			{
HXDLIN(  42)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  42)				int color = 0;
HXDLIN(  42)				if ((color == -1)) {
HXDLIN(  42)					color = _this1->currentColor;
            				}
HXDLIN(  42)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  42)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==2) ){
HXDLIN(  42)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  42)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  42)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN(  42)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  42)			 ::Dynamic sides = 36;
HXDLIN(  42)			if (::hx::IsNull( sides )) {
HXDLIN(  42)				sides = 36;
            			}
HXDLIN(  42)			Float pi = ::Math_obj::PI;
HXDLIN(  42)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  42)			Float dif;
HXDLIN(  42)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  42)					Float f;
HXDLIN(  42)					bool f1;
HXDLIN(  42)					if ((beta >= 0)) {
HXDLIN(  42)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f1 = false;
            					}
HXDLIN(  42)					if (f1) {
HXDLIN(  42)						f = beta;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f = a;
            						}
            						else {
HXDLIN(  42)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this1 = f;
HXDLIN(  42)					Float za = this1;
HXDLIN(  42)					Float f2;
HXDLIN(  42)					bool f3;
HXDLIN(  42)					if ((gamma >= 0)) {
HXDLIN(  42)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f3 = false;
            					}
HXDLIN(  42)					if (f3) {
HXDLIN(  42)						f2 = gamma;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f2 = a;
            						}
            						else {
HXDLIN(  42)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this2 = f2;
HXDLIN(  42)					Float zb = this2;
HXDLIN(  42)					Float fa = za;
HXDLIN(  42)					Float fb = zb;
HXDLIN(  42)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)					bool clockwise = (fa < fb);
HXDLIN(  42)					Float dif1;
HXDLIN(  42)					if (clockwise) {
HXDLIN(  42)						dif1 = theta;
            					}
            					else {
HXDLIN(  42)						dif1 = -(theta);
            					}
HXDLIN(  42)					if ((dif1 > 0)) {
HXDLIN(  42)						dif = dif1;
            					}
            					else {
HXDLIN(  42)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  42)					Float f;
HXDLIN(  42)					bool f1;
HXDLIN(  42)					if ((beta >= 0)) {
HXDLIN(  42)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f1 = false;
            					}
HXDLIN(  42)					if (f1) {
HXDLIN(  42)						f = beta;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f = a;
            						}
            						else {
HXDLIN(  42)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this1 = f;
HXDLIN(  42)					Float za = this1;
HXDLIN(  42)					Float f2;
HXDLIN(  42)					bool f3;
HXDLIN(  42)					if ((gamma >= 0)) {
HXDLIN(  42)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f3 = false;
            					}
HXDLIN(  42)					if (f3) {
HXDLIN(  42)						f2 = gamma;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f2 = a;
            						}
            						else {
HXDLIN(  42)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this2 = f2;
HXDLIN(  42)					Float zb = this2;
HXDLIN(  42)					Float fa = za;
HXDLIN(  42)					Float fb = zb;
HXDLIN(  42)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)					bool clockwise = (fa < fb);
HXDLIN(  42)					Float dif1;
HXDLIN(  42)					if (clockwise) {
HXDLIN(  42)						dif1 = theta;
            					}
            					else {
HXDLIN(  42)						dif1 = -(theta);
            					}
HXDLIN(  42)					if ((dif1 < 0)) {
HXDLIN(  42)						dif = dif1;
            					}
            					else {
HXDLIN(  42)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  42)					Float f;
HXDLIN(  42)					bool f1;
HXDLIN(  42)					if ((beta >= 0)) {
HXDLIN(  42)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f1 = false;
            					}
HXDLIN(  42)					if (f1) {
HXDLIN(  42)						f = beta;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f = a;
            						}
            						else {
HXDLIN(  42)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this1 = f;
HXDLIN(  42)					Float za = this1;
HXDLIN(  42)					Float f2;
HXDLIN(  42)					bool f3;
HXDLIN(  42)					if ((gamma >= 0)) {
HXDLIN(  42)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f3 = false;
            					}
HXDLIN(  42)					if (f3) {
HXDLIN(  42)						f2 = gamma;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f2 = a;
            						}
            						else {
HXDLIN(  42)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this2 = f2;
HXDLIN(  42)					Float zb = this2;
HXDLIN(  42)					Float fa = za;
HXDLIN(  42)					Float fb = zb;
HXDLIN(  42)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  42)					bool clockwise = (fa < fb);
HXDLIN(  42)					Float dif1;
HXDLIN(  42)					if (clockwise) {
HXDLIN(  42)						dif1 = theta;
            					}
            					else {
HXDLIN(  42)						dif1 = -(theta);
            					}
HXDLIN(  42)					if (smallest) {
HXDLIN(  42)						dif = dif1;
            					}
            					else {
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  42)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  42)					Float f;
HXDLIN(  42)					bool f1;
HXDLIN(  42)					if ((beta >= 0)) {
HXDLIN(  42)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f1 = false;
            					}
HXDLIN(  42)					if (f1) {
HXDLIN(  42)						f = beta;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f = a;
            						}
            						else {
HXDLIN(  42)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this1 = f;
HXDLIN(  42)					Float za = this1;
HXDLIN(  42)					Float f2;
HXDLIN(  42)					bool f3;
HXDLIN(  42)					if ((gamma >= 0)) {
HXDLIN(  42)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  42)						f3 = false;
            					}
HXDLIN(  42)					if (f3) {
HXDLIN(  42)						f2 = gamma;
            					}
            					else {
HXDLIN(  42)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)						if ((a >= 0)) {
HXDLIN(  42)							f2 = a;
            						}
            						else {
HXDLIN(  42)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  42)					Float this2 = f2;
HXDLIN(  42)					Float zb = this2;
HXDLIN(  42)					Float fa = za;
HXDLIN(  42)					Float fb = zb;
HXDLIN(  42)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  42)					bool clockwise = (fa < fb);
HXDLIN(  42)					Float dif1;
HXDLIN(  42)					if (clockwise) {
HXDLIN(  42)						dif1 = theta;
            					}
            					else {
HXDLIN(  42)						dif1 = -(theta);
            					}
HXDLIN(  42)					if (largest) {
HXDLIN(  42)						dif = dif1;
            					}
            					else {
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  42)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  42)			bool positive = (dif >= 0);
HXDLIN(  42)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  42)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  42)			Float angle = beta;
HXDLIN(  42)			Float cx;
HXDLIN(  42)			Float cy;
HXDLIN(  42)			Float bx = ( (Float)(0) );
HXDLIN(  42)			Float by = ( (Float)(0) );
HXDLIN(  42)			{
HXDLIN(  42)				int _g = 0;
HXDLIN(  42)				int _g1 = (totalSteps + 1);
HXDLIN(  42)				while((_g < _g1)){
HXDLIN(  42)					_g = (_g + 1);
HXDLIN(  42)					int i = (_g - 1);
HXDLIN(  42)					cx = (x_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  42)					cy = (y_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  42)					if ((i != 0)) {
HXDLIN(  42)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x_,y_,0,bx,by,0,cx,cy,0);
HXDLIN(  42)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  42)						if (::hx::IsNotNull( m )) {
HXDLIN(  42)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  42)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  42)					angle = (angle + step1);
HXDLIN(  42)					bx = cx;
HXDLIN(  42)					by = cy;
            				}
            			}
HXDLIN(  42)			int len = totalSteps;
HXDLIN(  42)			{
HXDLIN(  42)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  42)				int color = 0;
HXDLIN(  42)				if ((color == -1)) {
HXDLIN(  42)					color = _this1->currentColor;
            				}
HXDLIN(  42)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  42)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==3) ){
HXDLIN(  42)			{
HXDLIN(  42)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  42)				Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  42)				Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  42)				 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  42)				 ::Dynamic sides = 36;
HXDLIN(  42)				if (::hx::IsNull( sides )) {
HXDLIN(  42)					sides = 36;
            				}
HXDLIN(  42)				Float pi = ::Math_obj::PI;
HXDLIN(  42)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  42)				Float dif;
HXDLIN(  42)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  42)						Float f;
HXDLIN(  42)						bool f1;
HXDLIN(  42)						if ((beta >= 0)) {
HXDLIN(  42)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f1 = false;
            						}
HXDLIN(  42)						if (f1) {
HXDLIN(  42)							f = beta;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f = a;
            							}
            							else {
HXDLIN(  42)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this1 = f;
HXDLIN(  42)						Float za = this1;
HXDLIN(  42)						Float f2;
HXDLIN(  42)						bool f3;
HXDLIN(  42)						if ((gamma >= 0)) {
HXDLIN(  42)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f3 = false;
            						}
HXDLIN(  42)						if (f3) {
HXDLIN(  42)							f2 = gamma;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f2 = a;
            							}
            							else {
HXDLIN(  42)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this2 = f2;
HXDLIN(  42)						Float zb = this2;
HXDLIN(  42)						Float fa = za;
HXDLIN(  42)						Float fb = zb;
HXDLIN(  42)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)						bool clockwise = (fa < fb);
HXDLIN(  42)						Float dif1;
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif1 = theta;
            						}
            						else {
HXDLIN(  42)							dif1 = -(theta);
            						}
HXDLIN(  42)						if ((dif1 > 0)) {
HXDLIN(  42)							dif = dif1;
            						}
            						else {
HXDLIN(  42)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  42)						Float f;
HXDLIN(  42)						bool f1;
HXDLIN(  42)						if ((beta >= 0)) {
HXDLIN(  42)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f1 = false;
            						}
HXDLIN(  42)						if (f1) {
HXDLIN(  42)							f = beta;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f = a;
            							}
            							else {
HXDLIN(  42)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this1 = f;
HXDLIN(  42)						Float za = this1;
HXDLIN(  42)						Float f2;
HXDLIN(  42)						bool f3;
HXDLIN(  42)						if ((gamma >= 0)) {
HXDLIN(  42)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f3 = false;
            						}
HXDLIN(  42)						if (f3) {
HXDLIN(  42)							f2 = gamma;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f2 = a;
            							}
            							else {
HXDLIN(  42)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this2 = f2;
HXDLIN(  42)						Float zb = this2;
HXDLIN(  42)						Float fa = za;
HXDLIN(  42)						Float fb = zb;
HXDLIN(  42)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)						bool clockwise = (fa < fb);
HXDLIN(  42)						Float dif1;
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif1 = theta;
            						}
            						else {
HXDLIN(  42)							dif1 = -(theta);
            						}
HXDLIN(  42)						if ((dif1 < 0)) {
HXDLIN(  42)							dif = dif1;
            						}
            						else {
HXDLIN(  42)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  42)						Float f;
HXDLIN(  42)						bool f1;
HXDLIN(  42)						if ((beta >= 0)) {
HXDLIN(  42)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f1 = false;
            						}
HXDLIN(  42)						if (f1) {
HXDLIN(  42)							f = beta;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f = a;
            							}
            							else {
HXDLIN(  42)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this1 = f;
HXDLIN(  42)						Float za = this1;
HXDLIN(  42)						Float f2;
HXDLIN(  42)						bool f3;
HXDLIN(  42)						if ((gamma >= 0)) {
HXDLIN(  42)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f3 = false;
            						}
HXDLIN(  42)						if (f3) {
HXDLIN(  42)							f2 = gamma;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f2 = a;
            							}
            							else {
HXDLIN(  42)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this2 = f2;
HXDLIN(  42)						Float zb = this2;
HXDLIN(  42)						Float fa = za;
HXDLIN(  42)						Float fb = zb;
HXDLIN(  42)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  42)						bool clockwise = (fa < fb);
HXDLIN(  42)						Float dif1;
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif1 = theta;
            						}
            						else {
HXDLIN(  42)							dif1 = -(theta);
            						}
HXDLIN(  42)						if (smallest) {
HXDLIN(  42)							dif = dif1;
            						}
            						else {
HXDLIN(  42)							if (clockwise) {
HXDLIN(  42)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  42)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  42)						Float f;
HXDLIN(  42)						bool f1;
HXDLIN(  42)						if ((beta >= 0)) {
HXDLIN(  42)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f1 = false;
            						}
HXDLIN(  42)						if (f1) {
HXDLIN(  42)							f = beta;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f = a;
            							}
            							else {
HXDLIN(  42)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this1 = f;
HXDLIN(  42)						Float za = this1;
HXDLIN(  42)						Float f2;
HXDLIN(  42)						bool f3;
HXDLIN(  42)						if ((gamma >= 0)) {
HXDLIN(  42)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f3 = false;
            						}
HXDLIN(  42)						if (f3) {
HXDLIN(  42)							f2 = gamma;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f2 = a;
            							}
            							else {
HXDLIN(  42)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this2 = f2;
HXDLIN(  42)						Float zb = this2;
HXDLIN(  42)						Float fa = za;
HXDLIN(  42)						Float fb = zb;
HXDLIN(  42)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  42)						bool clockwise = (fa < fb);
HXDLIN(  42)						Float dif1;
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif1 = theta;
            						}
            						else {
HXDLIN(  42)							dif1 = -(theta);
            						}
HXDLIN(  42)						if (largest) {
HXDLIN(  42)							dif = dif1;
            						}
            						else {
HXDLIN(  42)							if (clockwise) {
HXDLIN(  42)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  42)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  42)				bool positive = (dif >= 0);
HXDLIN(  42)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  42)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  42)				Float angle = beta;
HXDLIN(  42)				Float cx;
HXDLIN(  42)				Float cy;
HXDLIN(  42)				Float bx = ( (Float)(0) );
HXDLIN(  42)				Float by = ( (Float)(0) );
HXDLIN(  42)				{
HXDLIN(  42)					int _g = 0;
HXDLIN(  42)					int _g1 = (totalSteps + 1);
HXDLIN(  42)					while((_g < _g1)){
HXDLIN(  42)						_g = (_g + 1);
HXDLIN(  42)						int i = (_g - 1);
HXDLIN(  42)						cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  42)						cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  42)						if ((i != 0)) {
HXDLIN(  42)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  42)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  42)							if (::hx::IsNotNull( m )) {
HXDLIN(  42)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  42)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  42)						angle = (angle + step1);
HXDLIN(  42)						bx = cx;
HXDLIN(  42)						by = cy;
            					}
            				}
HXDLIN(  42)				int len = totalSteps;
HXDLIN(  42)				{
HXDLIN(  42)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  42)					int color = 0;
HXDLIN(  42)					if ((color == -1)) {
HXDLIN(  42)						color = _this1->currentColor;
            					}
HXDLIN(  42)					_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            				}
            			}
HXDLIN(  42)			{
HXDLIN(  42)				Float radius1 = (width_ / ( (Float)(2) ));
HXDLIN(  42)				Float beta1 = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  42)				Float gamma1 = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN(  42)				 ::Dynamic drawType1 = _this->pen->drawType;
HXDLIN(  42)				 ::Dynamic sides1 = 36;
HXDLIN(  42)				if (::hx::IsNull( sides1 )) {
HXDLIN(  42)					sides1 = 36;
            				}
HXDLIN(  42)				Float pi1 = ::Math_obj::PI;
HXDLIN(  42)				Float step2 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN(  42)				Float dif1;
HXDLIN(  42)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  42)						Float f;
HXDLIN(  42)						bool f1;
HXDLIN(  42)						if ((beta1 >= 0)) {
HXDLIN(  42)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f1 = false;
            						}
HXDLIN(  42)						if (f1) {
HXDLIN(  42)							f = beta1;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f = a;
            							}
            							else {
HXDLIN(  42)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this1 = f;
HXDLIN(  42)						Float za = this1;
HXDLIN(  42)						Float f2;
HXDLIN(  42)						bool f3;
HXDLIN(  42)						if ((gamma1 >= 0)) {
HXDLIN(  42)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f3 = false;
            						}
HXDLIN(  42)						if (f3) {
HXDLIN(  42)							f2 = gamma1;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f2 = a;
            							}
            							else {
HXDLIN(  42)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this2 = f2;
HXDLIN(  42)						Float zb = this2;
HXDLIN(  42)						Float fa = za;
HXDLIN(  42)						Float fb = zb;
HXDLIN(  42)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)						bool clockwise = (fa < fb);
HXDLIN(  42)						Float dif;
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif = theta;
            						}
            						else {
HXDLIN(  42)							dif = -(theta);
            						}
HXDLIN(  42)						if ((dif > 0)) {
HXDLIN(  42)							dif1 = dif;
            						}
            						else {
HXDLIN(  42)							dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  42)						Float f;
HXDLIN(  42)						bool f1;
HXDLIN(  42)						if ((beta1 >= 0)) {
HXDLIN(  42)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f1 = false;
            						}
HXDLIN(  42)						if (f1) {
HXDLIN(  42)							f = beta1;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f = a;
            							}
            							else {
HXDLIN(  42)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this1 = f;
HXDLIN(  42)						Float za = this1;
HXDLIN(  42)						Float f2;
HXDLIN(  42)						bool f3;
HXDLIN(  42)						if ((gamma1 >= 0)) {
HXDLIN(  42)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f3 = false;
            						}
HXDLIN(  42)						if (f3) {
HXDLIN(  42)							f2 = gamma1;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f2 = a;
            							}
            							else {
HXDLIN(  42)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this2 = f2;
HXDLIN(  42)						Float zb = this2;
HXDLIN(  42)						Float fa = za;
HXDLIN(  42)						Float fb = zb;
HXDLIN(  42)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)						bool clockwise = (fa < fb);
HXDLIN(  42)						Float dif;
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif = theta;
            						}
            						else {
HXDLIN(  42)							dif = -(theta);
            						}
HXDLIN(  42)						if ((dif < 0)) {
HXDLIN(  42)							dif1 = dif;
            						}
            						else {
HXDLIN(  42)							dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  42)						Float f;
HXDLIN(  42)						bool f1;
HXDLIN(  42)						if ((beta1 >= 0)) {
HXDLIN(  42)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f1 = false;
            						}
HXDLIN(  42)						if (f1) {
HXDLIN(  42)							f = beta1;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f = a;
            							}
            							else {
HXDLIN(  42)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this1 = f;
HXDLIN(  42)						Float za = this1;
HXDLIN(  42)						Float f2;
HXDLIN(  42)						bool f3;
HXDLIN(  42)						if ((gamma1 >= 0)) {
HXDLIN(  42)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f3 = false;
            						}
HXDLIN(  42)						if (f3) {
HXDLIN(  42)							f2 = gamma1;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f2 = a;
            							}
            							else {
HXDLIN(  42)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this2 = f2;
HXDLIN(  42)						Float zb = this2;
HXDLIN(  42)						Float fa = za;
HXDLIN(  42)						Float fb = zb;
HXDLIN(  42)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  42)						bool clockwise = (fa < fb);
HXDLIN(  42)						Float dif;
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif = theta;
            						}
            						else {
HXDLIN(  42)							dif = -(theta);
            						}
HXDLIN(  42)						if (smallest) {
HXDLIN(  42)							dif1 = dif;
            						}
            						else {
HXDLIN(  42)							if (clockwise) {
HXDLIN(  42)								dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  42)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  42)						Float f;
HXDLIN(  42)						bool f1;
HXDLIN(  42)						if ((beta1 >= 0)) {
HXDLIN(  42)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f1 = false;
            						}
HXDLIN(  42)						if (f1) {
HXDLIN(  42)							f = beta1;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f = a;
            							}
            							else {
HXDLIN(  42)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this1 = f;
HXDLIN(  42)						Float za = this1;
HXDLIN(  42)						Float f2;
HXDLIN(  42)						bool f3;
HXDLIN(  42)						if ((gamma1 >= 0)) {
HXDLIN(  42)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  42)							f3 = false;
            						}
HXDLIN(  42)						if (f3) {
HXDLIN(  42)							f2 = gamma1;
            						}
            						else {
HXDLIN(  42)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  42)							if ((a >= 0)) {
HXDLIN(  42)								f2 = a;
            							}
            							else {
HXDLIN(  42)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  42)						Float this2 = f2;
HXDLIN(  42)						Float zb = this2;
HXDLIN(  42)						Float fa = za;
HXDLIN(  42)						Float fb = zb;
HXDLIN(  42)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  42)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  42)						bool clockwise = (fa < fb);
HXDLIN(  42)						Float dif;
HXDLIN(  42)						if (clockwise) {
HXDLIN(  42)							dif = theta;
            						}
            						else {
HXDLIN(  42)							dif = -(theta);
            						}
HXDLIN(  42)						if (largest) {
HXDLIN(  42)							dif1 = dif;
            						}
            						else {
HXDLIN(  42)							if (clockwise) {
HXDLIN(  42)								dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  42)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  42)				bool positive1 = (dif1 >= 0);
HXDLIN(  42)				int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN(  42)				Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN(  42)				Float angle1 = beta1;
HXDLIN(  42)				Float cx1;
HXDLIN(  42)				Float cy1;
HXDLIN(  42)				Float bx1 = ( (Float)(0) );
HXDLIN(  42)				Float by1 = ( (Float)(0) );
HXDLIN(  42)				{
HXDLIN(  42)					int _g2 = 0;
HXDLIN(  42)					int _g3 = (totalSteps1 + 1);
HXDLIN(  42)					while((_g2 < _g3)){
HXDLIN(  42)						_g2 = (_g2 + 1);
HXDLIN(  42)						int i = (_g2 - 1);
HXDLIN(  42)						cx1 = (x_ + (radius1 * ::Math_obj::sin(angle1)));
HXDLIN(  42)						cy1 = (y_ + (radius1 * ::Math_obj::cos(angle1)));
HXDLIN(  42)						if ((i != 0)) {
HXDLIN(  42)							drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x_,y_,0,bx1,by1,0,cx1,cy1,0);
HXDLIN(  42)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  42)							if (::hx::IsNotNull( m )) {
HXDLIN(  42)								drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  42)							drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  42)						angle1 = (angle1 + step3);
HXDLIN(  42)						bx1 = cx1;
HXDLIN(  42)						by1 = cy1;
            					}
            				}
HXDLIN(  42)				int len1 = totalSteps1;
HXDLIN(  42)				{
HXDLIN(  42)					 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  42)					int color1 = 0;
HXDLIN(  42)					if ((color1 == -1)) {
HXDLIN(  42)						color1 = _this2->currentColor;
            					}
HXDLIN(  42)					_this2->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            				}
            			}
HXDLIN(  42)			goto _hx_goto_5;
            		}
            		_hx_goto_5:;
HXDLIN(  42)		{
HXDLIN(  42)			 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  42)			int color = -1;
HXDLIN(  42)			if ((color == -1)) {
HXDLIN(  42)				color = _this1->currentColor;
            			}
HXDLIN(  42)			{
HXDLIN(  42)				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
HXDLIN(  42)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  42)					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  42)				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  42)			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
HXDLIN(  42)		{
HXDLIN(  42)			 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  42)			int color1 = -1;
HXDLIN(  42)			if ((color1 == -1)) {
HXDLIN(  42)				color1 = _this2->currentColor;
            			}
HXDLIN(  42)			{
HXDLIN(  42)				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  42)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  42)					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  42)				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  42)			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,roundEndLine,(void))

void Sketch_obj::mediumLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_45_mediumLine)
HXDLIN(  45)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  45)		Float ax_ = this->x;
HXDLIN(  45)		Float ay_ = this->y;
HXDLIN(  45)		Float width_ = this->width;
HXDLIN(  45)		bool overlap = false;
HXDLIN(  45)		 ::Dynamic oldAngle;
HXDLIN(  45)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  45)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  45)			oldAngle = null();
            		}
HXDLIN(  45)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  45)		_this->ax = x_;
HXDLIN(  45)		_this->ay = y_;
HXDLIN(  45)		_this->bx = ax_;
HXDLIN(  45)		_this->by = ay_;
HXDLIN(  45)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  45)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  45)		{
HXDLIN(  45)			{
HXDLIN(  45)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  45)				if ((_this->theta > 0)) {
HXDLIN(  45)					if ((_this->halfA < 0)) {
HXDLIN(  45)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  45)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  45)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  45)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  45)					if ((_this->halfA > 0)) {
HXDLIN(  45)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  45)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  45)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  45)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  45)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  45)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  45)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  45)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  45)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  45)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  45)				_this->exPrev = _this->ex;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  45)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  45)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  45)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  45)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  45)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  45)		_this->ax = ax_;
HXDLIN(  45)		_this->ay = ay_;
HXDLIN(  45)		_this->bx = x_;
HXDLIN(  45)		_this->by = y_;
HXDLIN(  45)		{
HXDLIN(  45)			{
HXDLIN(  45)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  45)				if ((_this->theta > 0)) {
HXDLIN(  45)					if ((_this->halfA < 0)) {
HXDLIN(  45)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  45)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  45)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  45)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  45)					if ((_this->halfA > 0)) {
HXDLIN(  45)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  45)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  45)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  45)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  45)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  45)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  45)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  45)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  45)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  45)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  45)				_this->exPrev = _this->ex;
            			}
HXDLIN(  45)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  45)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  45)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  45)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  45)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  45)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  45)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  45)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  45)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  45)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  45)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  45)		Float theta0;
HXDLIN(  45)		Float theta1;
HXDLIN(  45)		if (clockWise) {
HXDLIN(  45)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  45)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  45)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  45)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  45)		Float dif;
HXDLIN(  45)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  45)				Float f;
HXDLIN(  45)				bool f1;
HXDLIN(  45)				if ((theta0 >= 0)) {
HXDLIN(  45)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  45)					f1 = false;
            				}
HXDLIN(  45)				if (f1) {
HXDLIN(  45)					f = theta0;
            				}
            				else {
HXDLIN(  45)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)					if ((a >= 0)) {
HXDLIN(  45)						f = a;
            					}
            					else {
HXDLIN(  45)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  45)				Float this1 = f;
HXDLIN(  45)				Float za = this1;
HXDLIN(  45)				Float f2;
HXDLIN(  45)				bool f3;
HXDLIN(  45)				if ((theta1 >= 0)) {
HXDLIN(  45)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  45)					f3 = false;
            				}
HXDLIN(  45)				if (f3) {
HXDLIN(  45)					f2 = theta1;
            				}
            				else {
HXDLIN(  45)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)					if ((a >= 0)) {
HXDLIN(  45)						f2 = a;
            					}
            					else {
HXDLIN(  45)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  45)				Float this2 = f2;
HXDLIN(  45)				Float zb = this2;
HXDLIN(  45)				Float fa = za;
HXDLIN(  45)				Float fb = zb;
HXDLIN(  45)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  45)				bool clockwise = (fa < fb);
HXDLIN(  45)				Float dif1;
HXDLIN(  45)				if (clockwise) {
HXDLIN(  45)					dif1 = theta;
            				}
            				else {
HXDLIN(  45)					dif1 = -(theta);
            				}
HXDLIN(  45)				if ((dif1 > 0)) {
HXDLIN(  45)					dif = dif1;
            				}
            				else {
HXDLIN(  45)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  45)				Float f;
HXDLIN(  45)				bool f1;
HXDLIN(  45)				if ((theta0 >= 0)) {
HXDLIN(  45)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  45)					f1 = false;
            				}
HXDLIN(  45)				if (f1) {
HXDLIN(  45)					f = theta0;
            				}
            				else {
HXDLIN(  45)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)					if ((a >= 0)) {
HXDLIN(  45)						f = a;
            					}
            					else {
HXDLIN(  45)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  45)				Float this1 = f;
HXDLIN(  45)				Float za = this1;
HXDLIN(  45)				Float f2;
HXDLIN(  45)				bool f3;
HXDLIN(  45)				if ((theta1 >= 0)) {
HXDLIN(  45)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  45)					f3 = false;
            				}
HXDLIN(  45)				if (f3) {
HXDLIN(  45)					f2 = theta1;
            				}
            				else {
HXDLIN(  45)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)					if ((a >= 0)) {
HXDLIN(  45)						f2 = a;
            					}
            					else {
HXDLIN(  45)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  45)				Float this2 = f2;
HXDLIN(  45)				Float zb = this2;
HXDLIN(  45)				Float fa = za;
HXDLIN(  45)				Float fb = zb;
HXDLIN(  45)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  45)				bool clockwise = (fa < fb);
HXDLIN(  45)				Float dif1;
HXDLIN(  45)				if (clockwise) {
HXDLIN(  45)					dif1 = theta;
            				}
            				else {
HXDLIN(  45)					dif1 = -(theta);
            				}
HXDLIN(  45)				if ((dif1 < 0)) {
HXDLIN(  45)					dif = dif1;
            				}
            				else {
HXDLIN(  45)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  45)				Float f;
HXDLIN(  45)				bool f1;
HXDLIN(  45)				if ((theta0 >= 0)) {
HXDLIN(  45)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  45)					f1 = false;
            				}
HXDLIN(  45)				if (f1) {
HXDLIN(  45)					f = theta0;
            				}
            				else {
HXDLIN(  45)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)					if ((a >= 0)) {
HXDLIN(  45)						f = a;
            					}
            					else {
HXDLIN(  45)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  45)				Float this1 = f;
HXDLIN(  45)				Float za = this1;
HXDLIN(  45)				Float f2;
HXDLIN(  45)				bool f3;
HXDLIN(  45)				if ((theta1 >= 0)) {
HXDLIN(  45)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  45)					f3 = false;
            				}
HXDLIN(  45)				if (f3) {
HXDLIN(  45)					f2 = theta1;
            				}
            				else {
HXDLIN(  45)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)					if ((a >= 0)) {
HXDLIN(  45)						f2 = a;
            					}
            					else {
HXDLIN(  45)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  45)				Float this2 = f2;
HXDLIN(  45)				Float zb = this2;
HXDLIN(  45)				Float fa = za;
HXDLIN(  45)				Float fb = zb;
HXDLIN(  45)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  45)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  45)				bool clockwise = (fa < fb);
HXDLIN(  45)				Float dif1;
HXDLIN(  45)				if (clockwise) {
HXDLIN(  45)					dif1 = theta;
            				}
            				else {
HXDLIN(  45)					dif1 = -(theta);
            				}
HXDLIN(  45)				if (smallest) {
HXDLIN(  45)					dif = dif1;
            				}
            				else {
HXDLIN(  45)					if (clockwise) {
HXDLIN(  45)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  45)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  45)				Float f;
HXDLIN(  45)				bool f1;
HXDLIN(  45)				if ((theta0 >= 0)) {
HXDLIN(  45)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  45)					f1 = false;
            				}
HXDLIN(  45)				if (f1) {
HXDLIN(  45)					f = theta0;
            				}
            				else {
HXDLIN(  45)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)					if ((a >= 0)) {
HXDLIN(  45)						f = a;
            					}
            					else {
HXDLIN(  45)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  45)				Float this1 = f;
HXDLIN(  45)				Float za = this1;
HXDLIN(  45)				Float f2;
HXDLIN(  45)				bool f3;
HXDLIN(  45)				if ((theta1 >= 0)) {
HXDLIN(  45)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  45)					f3 = false;
            				}
HXDLIN(  45)				if (f3) {
HXDLIN(  45)					f2 = theta1;
            				}
            				else {
HXDLIN(  45)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)					if ((a >= 0)) {
HXDLIN(  45)						f2 = a;
            					}
            					else {
HXDLIN(  45)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  45)				Float this2 = f2;
HXDLIN(  45)				Float zb = this2;
HXDLIN(  45)				Float fa = za;
HXDLIN(  45)				Float fb = zb;
HXDLIN(  45)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  45)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  45)				bool clockwise = (fa < fb);
HXDLIN(  45)				Float dif1;
HXDLIN(  45)				if (clockwise) {
HXDLIN(  45)					dif1 = theta;
            				}
            				else {
HXDLIN(  45)					dif1 = -(theta);
            				}
HXDLIN(  45)				if (largest) {
HXDLIN(  45)					dif = dif1;
            				}
            				else {
HXDLIN(  45)					if (clockwise) {
HXDLIN(  45)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  45)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  45)		bool _hx_tmp;
HXDLIN(  45)		if (!(overlap)) {
HXDLIN(  45)			_hx_tmp = (_this->count != 0);
            		}
            		else {
HXDLIN(  45)			_hx_tmp = false;
            		}
HXDLIN(  45)		if (_hx_tmp) {
HXDLIN(  45)			Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXDLIN(  45)			Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXDLIN(  45)			Float f;
HXDLIN(  45)			bool f1;
HXDLIN(  45)			if ((theta0 <= ::Math_obj::PI)) {
HXDLIN(  45)				f1 = (theta0 > -(::Math_obj::PI));
            			}
            			else {
HXDLIN(  45)				f1 = false;
            			}
HXDLIN(  45)			if (f1) {
HXDLIN(  45)				f = theta0;
            			}
            			else {
HXDLIN(  45)				Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)				if ((a >= 0)) {
HXDLIN(  45)					f = (a - ::Math_obj::PI);
            				}
            				else {
HXDLIN(  45)					f = (a + ::Math_obj::PI);
            				}
            			}
HXDLIN(  45)			Float this1 = f;
HXDLIN(  45)			Float start = this1;
HXDLIN(  45)			Float start2 = start;
HXDLIN(  45)			Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  45)			_this->jx = (_this->ax + (h * ::Math_obj::sin(delta)));
HXDLIN(  45)			_this->jy = (_this->ay + (h * ::Math_obj::cos(delta)));
            		}
HXDLIN(  45)		bool _hx_tmp1;
HXDLIN(  45)		if ((_this->count == 0)) {
HXDLIN(  45)			if ((_this->endLine != 1)) {
HXDLIN(  45)				_hx_tmp1 = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  45)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXDLIN(  45)			_hx_tmp1 = false;
            		}
HXDLIN(  45)		if (_hx_tmp1) {
HXDLIN(  45)			Float ax = _this->ax;
HXDLIN(  45)			Float ay = _this->ay;
HXDLIN(  45)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  45)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  45)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  45)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  45)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  45)			 ::Dynamic sides = 36;
HXDLIN(  45)			if (::hx::IsNull( sides )) {
HXDLIN(  45)				sides = 36;
            			}
HXDLIN(  45)			Float pi = ::Math_obj::PI;
HXDLIN(  45)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  45)			Float dif;
HXDLIN(  45)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  45)					Float f;
HXDLIN(  45)					bool f1;
HXDLIN(  45)					if ((beta >= 0)) {
HXDLIN(  45)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  45)						f1 = false;
            					}
HXDLIN(  45)					if (f1) {
HXDLIN(  45)						f = beta;
            					}
            					else {
HXDLIN(  45)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)						if ((a >= 0)) {
HXDLIN(  45)							f = a;
            						}
            						else {
HXDLIN(  45)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  45)					Float this1 = f;
HXDLIN(  45)					Float za = this1;
HXDLIN(  45)					Float f2;
HXDLIN(  45)					bool f3;
HXDLIN(  45)					if ((gamma >= 0)) {
HXDLIN(  45)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  45)						f3 = false;
            					}
HXDLIN(  45)					if (f3) {
HXDLIN(  45)						f2 = gamma;
            					}
            					else {
HXDLIN(  45)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)						if ((a >= 0)) {
HXDLIN(  45)							f2 = a;
            						}
            						else {
HXDLIN(  45)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  45)					Float this2 = f2;
HXDLIN(  45)					Float zb = this2;
HXDLIN(  45)					Float fa = za;
HXDLIN(  45)					Float fb = zb;
HXDLIN(  45)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  45)					bool clockwise = (fa < fb);
HXDLIN(  45)					Float dif1;
HXDLIN(  45)					if (clockwise) {
HXDLIN(  45)						dif1 = theta;
            					}
            					else {
HXDLIN(  45)						dif1 = -(theta);
            					}
HXDLIN(  45)					if ((dif1 > 0)) {
HXDLIN(  45)						dif = dif1;
            					}
            					else {
HXDLIN(  45)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  45)					Float f;
HXDLIN(  45)					bool f1;
HXDLIN(  45)					if ((beta >= 0)) {
HXDLIN(  45)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  45)						f1 = false;
            					}
HXDLIN(  45)					if (f1) {
HXDLIN(  45)						f = beta;
            					}
            					else {
HXDLIN(  45)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)						if ((a >= 0)) {
HXDLIN(  45)							f = a;
            						}
            						else {
HXDLIN(  45)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  45)					Float this1 = f;
HXDLIN(  45)					Float za = this1;
HXDLIN(  45)					Float f2;
HXDLIN(  45)					bool f3;
HXDLIN(  45)					if ((gamma >= 0)) {
HXDLIN(  45)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  45)						f3 = false;
            					}
HXDLIN(  45)					if (f3) {
HXDLIN(  45)						f2 = gamma;
            					}
            					else {
HXDLIN(  45)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)						if ((a >= 0)) {
HXDLIN(  45)							f2 = a;
            						}
            						else {
HXDLIN(  45)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  45)					Float this2 = f2;
HXDLIN(  45)					Float zb = this2;
HXDLIN(  45)					Float fa = za;
HXDLIN(  45)					Float fb = zb;
HXDLIN(  45)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  45)					bool clockwise = (fa < fb);
HXDLIN(  45)					Float dif1;
HXDLIN(  45)					if (clockwise) {
HXDLIN(  45)						dif1 = theta;
            					}
            					else {
HXDLIN(  45)						dif1 = -(theta);
            					}
HXDLIN(  45)					if ((dif1 < 0)) {
HXDLIN(  45)						dif = dif1;
            					}
            					else {
HXDLIN(  45)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  45)					Float f;
HXDLIN(  45)					bool f1;
HXDLIN(  45)					if ((beta >= 0)) {
HXDLIN(  45)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  45)						f1 = false;
            					}
HXDLIN(  45)					if (f1) {
HXDLIN(  45)						f = beta;
            					}
            					else {
HXDLIN(  45)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)						if ((a >= 0)) {
HXDLIN(  45)							f = a;
            						}
            						else {
HXDLIN(  45)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  45)					Float this1 = f;
HXDLIN(  45)					Float za = this1;
HXDLIN(  45)					Float f2;
HXDLIN(  45)					bool f3;
HXDLIN(  45)					if ((gamma >= 0)) {
HXDLIN(  45)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  45)						f3 = false;
            					}
HXDLIN(  45)					if (f3) {
HXDLIN(  45)						f2 = gamma;
            					}
            					else {
HXDLIN(  45)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)						if ((a >= 0)) {
HXDLIN(  45)							f2 = a;
            						}
            						else {
HXDLIN(  45)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  45)					Float this2 = f2;
HXDLIN(  45)					Float zb = this2;
HXDLIN(  45)					Float fa = za;
HXDLIN(  45)					Float fb = zb;
HXDLIN(  45)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  45)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  45)					bool clockwise = (fa < fb);
HXDLIN(  45)					Float dif1;
HXDLIN(  45)					if (clockwise) {
HXDLIN(  45)						dif1 = theta;
            					}
            					else {
HXDLIN(  45)						dif1 = -(theta);
            					}
HXDLIN(  45)					if (smallest) {
HXDLIN(  45)						dif = dif1;
            					}
            					else {
HXDLIN(  45)						if (clockwise) {
HXDLIN(  45)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  45)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  45)					Float f;
HXDLIN(  45)					bool f1;
HXDLIN(  45)					if ((beta >= 0)) {
HXDLIN(  45)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  45)						f1 = false;
            					}
HXDLIN(  45)					if (f1) {
HXDLIN(  45)						f = beta;
            					}
            					else {
HXDLIN(  45)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)						if ((a >= 0)) {
HXDLIN(  45)							f = a;
            						}
            						else {
HXDLIN(  45)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  45)					Float this1 = f;
HXDLIN(  45)					Float za = this1;
HXDLIN(  45)					Float f2;
HXDLIN(  45)					bool f3;
HXDLIN(  45)					if ((gamma >= 0)) {
HXDLIN(  45)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  45)						f3 = false;
            					}
HXDLIN(  45)					if (f3) {
HXDLIN(  45)						f2 = gamma;
            					}
            					else {
HXDLIN(  45)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)						if ((a >= 0)) {
HXDLIN(  45)							f2 = a;
            						}
            						else {
HXDLIN(  45)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  45)					Float this2 = f2;
HXDLIN(  45)					Float zb = this2;
HXDLIN(  45)					Float fa = za;
HXDLIN(  45)					Float fb = zb;
HXDLIN(  45)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  45)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  45)					bool clockwise = (fa < fb);
HXDLIN(  45)					Float dif1;
HXDLIN(  45)					if (clockwise) {
HXDLIN(  45)						dif1 = theta;
            					}
            					else {
HXDLIN(  45)						dif1 = -(theta);
            					}
HXDLIN(  45)					if (largest) {
HXDLIN(  45)						dif = dif1;
            					}
            					else {
HXDLIN(  45)						if (clockwise) {
HXDLIN(  45)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  45)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  45)			bool positive = (dif >= 0);
HXDLIN(  45)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  45)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  45)			Float angle = beta;
HXDLIN(  45)			Float cx;
HXDLIN(  45)			Float cy;
HXDLIN(  45)			Float bx = ( (Float)(0) );
HXDLIN(  45)			Float by = ( (Float)(0) );
HXDLIN(  45)			int p2 = temp->length;
HXDLIN(  45)			{
HXDLIN(  45)				int _g = 0;
HXDLIN(  45)				int _g1 = (totalSteps + 1);
HXDLIN(  45)				while((_g < _g1)){
HXDLIN(  45)					_g = (_g + 1);
HXDLIN(  45)					int i = (_g - 1);
HXDLIN(  45)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  45)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  45)					p2 = (p2 + 1);
HXDLIN(  45)					temp[(p2 - 1)] = cx;
HXDLIN(  45)					p2 = (p2 + 1);
HXDLIN(  45)					temp[(p2 - 1)] = cy;
HXDLIN(  45)					if ((i != 0)) {
HXDLIN(  45)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  45)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  45)						if (::hx::IsNotNull( m )) {
HXDLIN(  45)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  45)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  45)					angle = (angle + step1);
HXDLIN(  45)					bx = cx;
HXDLIN(  45)					by = cy;
            				}
            			}
HXDLIN(  45)			int len = totalSteps;
HXDLIN(  45)			{
HXDLIN(  45)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)				int color = -1;
HXDLIN(  45)				if ((color == -1)) {
HXDLIN(  45)					color = _this1->currentColor;
            				}
HXDLIN(  45)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  45)			int pA = _this->pointsAnti->length;
HXDLIN(  45)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  45)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  45)			{
HXDLIN(  45)				int _g2 = 0;
HXDLIN(  45)				int _g3 = p4;
HXDLIN(  45)				while((_g2 < _g3)){
HXDLIN(  45)					_g2 = (_g2 + 1);
HXDLIN(  45)					int i = (_g2 - 1);
HXDLIN(  45)					pA = (pA + 1);
HXDLIN(  45)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  45)					pA = (pA + 1);
HXDLIN(  45)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  45)			int pC = _this->pointsClock->length;
HXDLIN(  45)			{
HXDLIN(  45)				int _g4 = 0;
HXDLIN(  45)				int _g5 = p4;
HXDLIN(  45)				while((_g4 < _g5)){
HXDLIN(  45)					_g4 = (_g4 + 1);
HXDLIN(  45)					int i = (_g4 - 1);
HXDLIN(  45)					pC = (pC + 1);
HXDLIN(  45)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  45)					pC = (pC + 1);
HXDLIN(  45)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  45)		if (overlap) {
HXDLIN(  45)			{
HXDLIN(  45)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)				int color = -1;
HXDLIN(  45)				if ((color == -1)) {
HXDLIN(  45)					color = _this1->currentColor;
            				}
HXDLIN(  45)				{
HXDLIN(  45)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  45)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  45)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  45)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  45)			{
HXDLIN(  45)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  45)				int color1 = -1;
HXDLIN(  45)				if ((color1 == -1)) {
HXDLIN(  45)					color1 = _this2->currentColor;
            				}
HXDLIN(  45)				{
HXDLIN(  45)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  45)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  45)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  45)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            		else {
HXDLIN(  45)			if ((_this->count != 0)) {
HXDLIN(  45)				_this->addQuads(clockWise,width_);
            			}
HXDLIN(  45)			{
HXDLIN(  45)				_this->quadIndex = ( (Float)(_this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
HXDLIN(  45)				if ((_this->count == 0)) {
HXDLIN(  45)					_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  45)					_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  45)					_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  45)					_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  45)					_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  45)					_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  45)					_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  45)					_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  45)					{
HXDLIN(  45)						 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)						int color = -1;
HXDLIN(  45)						if ((color == -1)) {
HXDLIN(  45)							color = _this1->currentColor;
            						}
HXDLIN(  45)						{
HXDLIN(  45)							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  45)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  45)							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  45)						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
HXDLIN(  45)					{
HXDLIN(  45)						 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  45)						int color1 = -1;
HXDLIN(  45)						if ((color1 == -1)) {
HXDLIN(  45)							color1 = _this2->currentColor;
            						}
HXDLIN(  45)						{
HXDLIN(  45)							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  45)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  45)							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  45)						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            					}
            				}
            				else {
HXDLIN(  45)					bool _hx_tmp;
HXDLIN(  45)					if (clockWise) {
HXDLIN(  45)						_hx_tmp = !(_this->lastClock);
            					}
            					else {
HXDLIN(  45)						_hx_tmp = false;
            					}
HXDLIN(  45)					if (_hx_tmp) {
HXDLIN(  45)						_this->penultimateAX = _this->jx;
HXDLIN(  45)						_this->penultimateAY = _this->jy;
HXDLIN(  45)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  45)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  45)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  45)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  45)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  45)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  45)						{
HXDLIN(  45)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)							int color = -1;
HXDLIN(  45)							if ((color == -1)) {
HXDLIN(  45)								color = _this1->currentColor;
            							}
HXDLIN(  45)							{
HXDLIN(  45)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  45)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  45)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  45)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  45)						{
HXDLIN(  45)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  45)							int color1 = -1;
HXDLIN(  45)							if ((color1 == -1)) {
HXDLIN(  45)								color1 = _this2->currentColor;
            							}
HXDLIN(  45)							{
HXDLIN(  45)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  45)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  45)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  45)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  45)					bool _hx_tmp1;
HXDLIN(  45)					if (clockWise) {
HXDLIN(  45)						_hx_tmp1 = _this->lastClock;
            					}
            					else {
HXDLIN(  45)						_hx_tmp1 = false;
            					}
HXDLIN(  45)					if (_hx_tmp1) {
HXDLIN(  45)						_this->penultimateAX = _this->jx;
HXDLIN(  45)						_this->penultimateAY = _this->jy;
HXDLIN(  45)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  45)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  45)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  45)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  45)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  45)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  45)						{
HXDLIN(  45)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)							int color = -1;
HXDLIN(  45)							if ((color == -1)) {
HXDLIN(  45)								color = _this1->currentColor;
            							}
HXDLIN(  45)							{
HXDLIN(  45)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  45)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  45)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  45)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  45)						{
HXDLIN(  45)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  45)							int color1 = -1;
HXDLIN(  45)							if ((color1 == -1)) {
HXDLIN(  45)								color1 = _this2->currentColor;
            							}
HXDLIN(  45)							{
HXDLIN(  45)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  45)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  45)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  45)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  45)					bool _hx_tmp2;
HXDLIN(  45)					if (!(clockWise)) {
HXDLIN(  45)						_hx_tmp2 = !(_this->lastClock);
            					}
            					else {
HXDLIN(  45)						_hx_tmp2 = false;
            					}
HXDLIN(  45)					if (_hx_tmp2) {
HXDLIN(  45)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  45)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  45)						_this->lastClockX = _this->jx;
HXDLIN(  45)						_this->lastClockY = _this->jy;
HXDLIN(  45)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  45)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  45)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  45)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  45)						{
HXDLIN(  45)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)							int color = -1;
HXDLIN(  45)							if ((color == -1)) {
HXDLIN(  45)								color = _this1->currentColor;
            							}
HXDLIN(  45)							{
HXDLIN(  45)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,_this->jx,_this->jy,0);
HXDLIN(  45)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  45)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  45)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  45)						{
HXDLIN(  45)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  45)							int color1 = -1;
HXDLIN(  45)							if ((color1 == -1)) {
HXDLIN(  45)								color1 = _this2->currentColor;
            							}
HXDLIN(  45)							{
HXDLIN(  45)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  45)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  45)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  45)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  45)					bool _hx_tmp3;
HXDLIN(  45)					if (!(clockWise)) {
HXDLIN(  45)						_hx_tmp3 = _this->lastClock;
            					}
            					else {
HXDLIN(  45)						_hx_tmp3 = false;
            					}
HXDLIN(  45)					if (_hx_tmp3) {
HXDLIN(  45)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  45)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  45)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  45)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  45)						_this->penultimateCX = _this->jx;
HXDLIN(  45)						_this->penultimateCY = _this->jy;
HXDLIN(  45)						_this->lastClockX = ( (Float)(_this->dx) );
HXDLIN(  45)						_this->lastClockY = ( (Float)(_this->dy) );
HXDLIN(  45)						{
HXDLIN(  45)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)							int color = -1;
HXDLIN(  45)							if ((color == -1)) {
HXDLIN(  45)								color = _this1->currentColor;
            							}
HXDLIN(  45)							{
HXDLIN(  45)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  45)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  45)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  45)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  45)						{
HXDLIN(  45)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  45)							int color1 = -1;
HXDLIN(  45)							if ((color1 == -1)) {
HXDLIN(  45)								color1 = _this2->currentColor;
            							}
HXDLIN(  45)							{
HXDLIN(  45)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  45)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  45)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  45)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
            				}
            			}
            		}
HXDLIN(  45)		if ((_this->count != 0)) {
HXDLIN(  45)			if (overlap) {
HXDLIN(  45)				if (clockWise) {
HXDLIN(  45)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)					int color = -1;
HXDLIN(  45)					if ((color == -1)) {
HXDLIN(  45)						color = _this1->currentColor;
            					}
HXDLIN(  45)					{
HXDLIN(  45)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  45)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  45)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  45)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            				else {
HXDLIN(  45)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)					int color = -1;
HXDLIN(  45)					if ((color == -1)) {
HXDLIN(  45)						color = _this1->currentColor;
            					}
HXDLIN(  45)					{
HXDLIN(  45)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  45)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  45)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  45)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            			}
            			else {
HXDLIN(  45)				if (clockWise) {
HXDLIN(  45)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)					int color = -1;
HXDLIN(  45)					if ((color == -1)) {
HXDLIN(  45)						color = _this1->currentColor;
            					}
HXDLIN(  45)					{
HXDLIN(  45)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  45)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  45)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  45)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            				else {
HXDLIN(  45)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  45)					int color = -1;
HXDLIN(  45)					if ((color == -1)) {
HXDLIN(  45)						color = _this1->currentColor;
            					}
HXDLIN(  45)					{
HXDLIN(  45)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  45)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  45)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  45)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  45)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            			}
            		}
HXDLIN(  45)		{
HXDLIN(  45)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  45)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  45)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  45)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  45)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  45)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  45)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  45)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  45)		_this->jxOld = _this->jx;
HXDLIN(  45)		_this->jyOld = _this->jy;
HXDLIN(  45)		_this->lastClock = clockWise;
HXDLIN(  45)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,mediumLine,(void))

void Sketch_obj::mediumOverlapLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_48_mediumOverlapLine)
HXDLIN(  48)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  48)		Float ax_ = this->x;
HXDLIN(  48)		Float ay_ = this->y;
HXDLIN(  48)		Float width_ = this->width;
HXDLIN(  48)		 ::Dynamic oldAngle;
HXDLIN(  48)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  48)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  48)			oldAngle = null();
            		}
HXDLIN(  48)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  48)		_this->ax = x_;
HXDLIN(  48)		_this->ay = y_;
HXDLIN(  48)		_this->bx = ax_;
HXDLIN(  48)		_this->by = ay_;
HXDLIN(  48)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  48)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  48)		{
HXDLIN(  48)			{
HXDLIN(  48)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  48)				if ((_this->theta > 0)) {
HXDLIN(  48)					if ((_this->halfA < 0)) {
HXDLIN(  48)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  48)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  48)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  48)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  48)					if ((_this->halfA > 0)) {
HXDLIN(  48)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  48)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  48)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  48)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  48)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  48)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  48)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  48)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  48)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  48)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  48)				_this->exPrev = _this->ex;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  48)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  48)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  48)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  48)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  48)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  48)		_this->ax = ax_;
HXDLIN(  48)		_this->ay = ay_;
HXDLIN(  48)		_this->bx = x_;
HXDLIN(  48)		_this->by = y_;
HXDLIN(  48)		{
HXDLIN(  48)			{
HXDLIN(  48)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  48)				if ((_this->theta > 0)) {
HXDLIN(  48)					if ((_this->halfA < 0)) {
HXDLIN(  48)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  48)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  48)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  48)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  48)					if ((_this->halfA > 0)) {
HXDLIN(  48)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  48)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  48)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  48)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  48)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  48)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  48)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  48)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  48)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  48)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  48)				_this->exPrev = _this->ex;
            			}
HXDLIN(  48)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  48)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  48)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  48)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  48)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  48)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  48)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  48)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  48)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  48)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  48)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  48)		Float theta0;
HXDLIN(  48)		Float theta1;
HXDLIN(  48)		if (clockWise) {
HXDLIN(  48)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  48)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  48)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  48)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  48)		Float dif;
HXDLIN(  48)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  48)				Float f;
HXDLIN(  48)				bool f1;
HXDLIN(  48)				if ((theta0 >= 0)) {
HXDLIN(  48)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  48)					f1 = false;
            				}
HXDLIN(  48)				if (f1) {
HXDLIN(  48)					f = theta0;
            				}
            				else {
HXDLIN(  48)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)					if ((a >= 0)) {
HXDLIN(  48)						f = a;
            					}
            					else {
HXDLIN(  48)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  48)				Float this1 = f;
HXDLIN(  48)				Float za = this1;
HXDLIN(  48)				Float f2;
HXDLIN(  48)				bool f3;
HXDLIN(  48)				if ((theta1 >= 0)) {
HXDLIN(  48)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  48)					f3 = false;
            				}
HXDLIN(  48)				if (f3) {
HXDLIN(  48)					f2 = theta1;
            				}
            				else {
HXDLIN(  48)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)					if ((a >= 0)) {
HXDLIN(  48)						f2 = a;
            					}
            					else {
HXDLIN(  48)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  48)				Float this2 = f2;
HXDLIN(  48)				Float zb = this2;
HXDLIN(  48)				Float fa = za;
HXDLIN(  48)				Float fb = zb;
HXDLIN(  48)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  48)				bool clockwise = (fa < fb);
HXDLIN(  48)				Float dif1;
HXDLIN(  48)				if (clockwise) {
HXDLIN(  48)					dif1 = theta;
            				}
            				else {
HXDLIN(  48)					dif1 = -(theta);
            				}
HXDLIN(  48)				if ((dif1 > 0)) {
HXDLIN(  48)					dif = dif1;
            				}
            				else {
HXDLIN(  48)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  48)				Float f;
HXDLIN(  48)				bool f1;
HXDLIN(  48)				if ((theta0 >= 0)) {
HXDLIN(  48)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  48)					f1 = false;
            				}
HXDLIN(  48)				if (f1) {
HXDLIN(  48)					f = theta0;
            				}
            				else {
HXDLIN(  48)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)					if ((a >= 0)) {
HXDLIN(  48)						f = a;
            					}
            					else {
HXDLIN(  48)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  48)				Float this1 = f;
HXDLIN(  48)				Float za = this1;
HXDLIN(  48)				Float f2;
HXDLIN(  48)				bool f3;
HXDLIN(  48)				if ((theta1 >= 0)) {
HXDLIN(  48)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  48)					f3 = false;
            				}
HXDLIN(  48)				if (f3) {
HXDLIN(  48)					f2 = theta1;
            				}
            				else {
HXDLIN(  48)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)					if ((a >= 0)) {
HXDLIN(  48)						f2 = a;
            					}
            					else {
HXDLIN(  48)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  48)				Float this2 = f2;
HXDLIN(  48)				Float zb = this2;
HXDLIN(  48)				Float fa = za;
HXDLIN(  48)				Float fb = zb;
HXDLIN(  48)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  48)				bool clockwise = (fa < fb);
HXDLIN(  48)				Float dif1;
HXDLIN(  48)				if (clockwise) {
HXDLIN(  48)					dif1 = theta;
            				}
            				else {
HXDLIN(  48)					dif1 = -(theta);
            				}
HXDLIN(  48)				if ((dif1 < 0)) {
HXDLIN(  48)					dif = dif1;
            				}
            				else {
HXDLIN(  48)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  48)				Float f;
HXDLIN(  48)				bool f1;
HXDLIN(  48)				if ((theta0 >= 0)) {
HXDLIN(  48)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  48)					f1 = false;
            				}
HXDLIN(  48)				if (f1) {
HXDLIN(  48)					f = theta0;
            				}
            				else {
HXDLIN(  48)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)					if ((a >= 0)) {
HXDLIN(  48)						f = a;
            					}
            					else {
HXDLIN(  48)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  48)				Float this1 = f;
HXDLIN(  48)				Float za = this1;
HXDLIN(  48)				Float f2;
HXDLIN(  48)				bool f3;
HXDLIN(  48)				if ((theta1 >= 0)) {
HXDLIN(  48)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  48)					f3 = false;
            				}
HXDLIN(  48)				if (f3) {
HXDLIN(  48)					f2 = theta1;
            				}
            				else {
HXDLIN(  48)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)					if ((a >= 0)) {
HXDLIN(  48)						f2 = a;
            					}
            					else {
HXDLIN(  48)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  48)				Float this2 = f2;
HXDLIN(  48)				Float zb = this2;
HXDLIN(  48)				Float fa = za;
HXDLIN(  48)				Float fb = zb;
HXDLIN(  48)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  48)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  48)				bool clockwise = (fa < fb);
HXDLIN(  48)				Float dif1;
HXDLIN(  48)				if (clockwise) {
HXDLIN(  48)					dif1 = theta;
            				}
            				else {
HXDLIN(  48)					dif1 = -(theta);
            				}
HXDLIN(  48)				if (smallest) {
HXDLIN(  48)					dif = dif1;
            				}
            				else {
HXDLIN(  48)					if (clockwise) {
HXDLIN(  48)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  48)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  48)				Float f;
HXDLIN(  48)				bool f1;
HXDLIN(  48)				if ((theta0 >= 0)) {
HXDLIN(  48)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  48)					f1 = false;
            				}
HXDLIN(  48)				if (f1) {
HXDLIN(  48)					f = theta0;
            				}
            				else {
HXDLIN(  48)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)					if ((a >= 0)) {
HXDLIN(  48)						f = a;
            					}
            					else {
HXDLIN(  48)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  48)				Float this1 = f;
HXDLIN(  48)				Float za = this1;
HXDLIN(  48)				Float f2;
HXDLIN(  48)				bool f3;
HXDLIN(  48)				if ((theta1 >= 0)) {
HXDLIN(  48)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  48)					f3 = false;
            				}
HXDLIN(  48)				if (f3) {
HXDLIN(  48)					f2 = theta1;
            				}
            				else {
HXDLIN(  48)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)					if ((a >= 0)) {
HXDLIN(  48)						f2 = a;
            					}
            					else {
HXDLIN(  48)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  48)				Float this2 = f2;
HXDLIN(  48)				Float zb = this2;
HXDLIN(  48)				Float fa = za;
HXDLIN(  48)				Float fb = zb;
HXDLIN(  48)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  48)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  48)				bool clockwise = (fa < fb);
HXDLIN(  48)				Float dif1;
HXDLIN(  48)				if (clockwise) {
HXDLIN(  48)					dif1 = theta;
            				}
            				else {
HXDLIN(  48)					dif1 = -(theta);
            				}
HXDLIN(  48)				if (largest) {
HXDLIN(  48)					dif = dif1;
            				}
            				else {
HXDLIN(  48)					if (clockwise) {
HXDLIN(  48)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  48)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  48)		bool _hx_tmp;
HXDLIN(  48)		if ((_this->count == 0)) {
HXDLIN(  48)			if ((_this->endLine != 1)) {
HXDLIN(  48)				_hx_tmp = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  48)				_hx_tmp = true;
            			}
            		}
            		else {
HXDLIN(  48)			_hx_tmp = false;
            		}
HXDLIN(  48)		if (_hx_tmp) {
HXDLIN(  48)			Float ax = _this->ax;
HXDLIN(  48)			Float ay = _this->ay;
HXDLIN(  48)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  48)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  48)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  48)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  48)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  48)			 ::Dynamic sides = 36;
HXDLIN(  48)			if (::hx::IsNull( sides )) {
HXDLIN(  48)				sides = 36;
            			}
HXDLIN(  48)			Float pi = ::Math_obj::PI;
HXDLIN(  48)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  48)			Float dif;
HXDLIN(  48)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  48)					Float f;
HXDLIN(  48)					bool f1;
HXDLIN(  48)					if ((beta >= 0)) {
HXDLIN(  48)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  48)						f1 = false;
            					}
HXDLIN(  48)					if (f1) {
HXDLIN(  48)						f = beta;
            					}
            					else {
HXDLIN(  48)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)						if ((a >= 0)) {
HXDLIN(  48)							f = a;
            						}
            						else {
HXDLIN(  48)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  48)					Float this1 = f;
HXDLIN(  48)					Float za = this1;
HXDLIN(  48)					Float f2;
HXDLIN(  48)					bool f3;
HXDLIN(  48)					if ((gamma >= 0)) {
HXDLIN(  48)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  48)						f3 = false;
            					}
HXDLIN(  48)					if (f3) {
HXDLIN(  48)						f2 = gamma;
            					}
            					else {
HXDLIN(  48)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)						if ((a >= 0)) {
HXDLIN(  48)							f2 = a;
            						}
            						else {
HXDLIN(  48)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  48)					Float this2 = f2;
HXDLIN(  48)					Float zb = this2;
HXDLIN(  48)					Float fa = za;
HXDLIN(  48)					Float fb = zb;
HXDLIN(  48)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  48)					bool clockwise = (fa < fb);
HXDLIN(  48)					Float dif1;
HXDLIN(  48)					if (clockwise) {
HXDLIN(  48)						dif1 = theta;
            					}
            					else {
HXDLIN(  48)						dif1 = -(theta);
            					}
HXDLIN(  48)					if ((dif1 > 0)) {
HXDLIN(  48)						dif = dif1;
            					}
            					else {
HXDLIN(  48)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  48)					Float f;
HXDLIN(  48)					bool f1;
HXDLIN(  48)					if ((beta >= 0)) {
HXDLIN(  48)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  48)						f1 = false;
            					}
HXDLIN(  48)					if (f1) {
HXDLIN(  48)						f = beta;
            					}
            					else {
HXDLIN(  48)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)						if ((a >= 0)) {
HXDLIN(  48)							f = a;
            						}
            						else {
HXDLIN(  48)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  48)					Float this1 = f;
HXDLIN(  48)					Float za = this1;
HXDLIN(  48)					Float f2;
HXDLIN(  48)					bool f3;
HXDLIN(  48)					if ((gamma >= 0)) {
HXDLIN(  48)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  48)						f3 = false;
            					}
HXDLIN(  48)					if (f3) {
HXDLIN(  48)						f2 = gamma;
            					}
            					else {
HXDLIN(  48)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)						if ((a >= 0)) {
HXDLIN(  48)							f2 = a;
            						}
            						else {
HXDLIN(  48)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  48)					Float this2 = f2;
HXDLIN(  48)					Float zb = this2;
HXDLIN(  48)					Float fa = za;
HXDLIN(  48)					Float fb = zb;
HXDLIN(  48)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  48)					bool clockwise = (fa < fb);
HXDLIN(  48)					Float dif1;
HXDLIN(  48)					if (clockwise) {
HXDLIN(  48)						dif1 = theta;
            					}
            					else {
HXDLIN(  48)						dif1 = -(theta);
            					}
HXDLIN(  48)					if ((dif1 < 0)) {
HXDLIN(  48)						dif = dif1;
            					}
            					else {
HXDLIN(  48)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  48)					Float f;
HXDLIN(  48)					bool f1;
HXDLIN(  48)					if ((beta >= 0)) {
HXDLIN(  48)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  48)						f1 = false;
            					}
HXDLIN(  48)					if (f1) {
HXDLIN(  48)						f = beta;
            					}
            					else {
HXDLIN(  48)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)						if ((a >= 0)) {
HXDLIN(  48)							f = a;
            						}
            						else {
HXDLIN(  48)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  48)					Float this1 = f;
HXDLIN(  48)					Float za = this1;
HXDLIN(  48)					Float f2;
HXDLIN(  48)					bool f3;
HXDLIN(  48)					if ((gamma >= 0)) {
HXDLIN(  48)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  48)						f3 = false;
            					}
HXDLIN(  48)					if (f3) {
HXDLIN(  48)						f2 = gamma;
            					}
            					else {
HXDLIN(  48)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)						if ((a >= 0)) {
HXDLIN(  48)							f2 = a;
            						}
            						else {
HXDLIN(  48)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  48)					Float this2 = f2;
HXDLIN(  48)					Float zb = this2;
HXDLIN(  48)					Float fa = za;
HXDLIN(  48)					Float fb = zb;
HXDLIN(  48)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  48)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  48)					bool clockwise = (fa < fb);
HXDLIN(  48)					Float dif1;
HXDLIN(  48)					if (clockwise) {
HXDLIN(  48)						dif1 = theta;
            					}
            					else {
HXDLIN(  48)						dif1 = -(theta);
            					}
HXDLIN(  48)					if (smallest) {
HXDLIN(  48)						dif = dif1;
            					}
            					else {
HXDLIN(  48)						if (clockwise) {
HXDLIN(  48)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  48)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  48)					Float f;
HXDLIN(  48)					bool f1;
HXDLIN(  48)					if ((beta >= 0)) {
HXDLIN(  48)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  48)						f1 = false;
            					}
HXDLIN(  48)					if (f1) {
HXDLIN(  48)						f = beta;
            					}
            					else {
HXDLIN(  48)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)						if ((a >= 0)) {
HXDLIN(  48)							f = a;
            						}
            						else {
HXDLIN(  48)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  48)					Float this1 = f;
HXDLIN(  48)					Float za = this1;
HXDLIN(  48)					Float f2;
HXDLIN(  48)					bool f3;
HXDLIN(  48)					if ((gamma >= 0)) {
HXDLIN(  48)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  48)						f3 = false;
            					}
HXDLIN(  48)					if (f3) {
HXDLIN(  48)						f2 = gamma;
            					}
            					else {
HXDLIN(  48)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  48)						if ((a >= 0)) {
HXDLIN(  48)							f2 = a;
            						}
            						else {
HXDLIN(  48)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  48)					Float this2 = f2;
HXDLIN(  48)					Float zb = this2;
HXDLIN(  48)					Float fa = za;
HXDLIN(  48)					Float fb = zb;
HXDLIN(  48)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  48)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  48)					bool clockwise = (fa < fb);
HXDLIN(  48)					Float dif1;
HXDLIN(  48)					if (clockwise) {
HXDLIN(  48)						dif1 = theta;
            					}
            					else {
HXDLIN(  48)						dif1 = -(theta);
            					}
HXDLIN(  48)					if (largest) {
HXDLIN(  48)						dif = dif1;
            					}
            					else {
HXDLIN(  48)						if (clockwise) {
HXDLIN(  48)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  48)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  48)			bool positive = (dif >= 0);
HXDLIN(  48)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  48)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  48)			Float angle = beta;
HXDLIN(  48)			Float cx;
HXDLIN(  48)			Float cy;
HXDLIN(  48)			Float bx = ( (Float)(0) );
HXDLIN(  48)			Float by = ( (Float)(0) );
HXDLIN(  48)			int p2 = temp->length;
HXDLIN(  48)			{
HXDLIN(  48)				int _g = 0;
HXDLIN(  48)				int _g1 = (totalSteps + 1);
HXDLIN(  48)				while((_g < _g1)){
HXDLIN(  48)					_g = (_g + 1);
HXDLIN(  48)					int i = (_g - 1);
HXDLIN(  48)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  48)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  48)					p2 = (p2 + 1);
HXDLIN(  48)					temp[(p2 - 1)] = cx;
HXDLIN(  48)					p2 = (p2 + 1);
HXDLIN(  48)					temp[(p2 - 1)] = cy;
HXDLIN(  48)					if ((i != 0)) {
HXDLIN(  48)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  48)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  48)						if (::hx::IsNotNull( m )) {
HXDLIN(  48)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  48)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  48)					angle = (angle + step1);
HXDLIN(  48)					bx = cx;
HXDLIN(  48)					by = cy;
            				}
            			}
HXDLIN(  48)			int len = totalSteps;
HXDLIN(  48)			{
HXDLIN(  48)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  48)				int color = -1;
HXDLIN(  48)				if ((color == -1)) {
HXDLIN(  48)					color = _this1->currentColor;
            				}
HXDLIN(  48)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  48)			int pA = _this->pointsAnti->length;
HXDLIN(  48)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  48)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  48)			{
HXDLIN(  48)				int _g2 = 0;
HXDLIN(  48)				int _g3 = p4;
HXDLIN(  48)				while((_g2 < _g3)){
HXDLIN(  48)					_g2 = (_g2 + 1);
HXDLIN(  48)					int i = (_g2 - 1);
HXDLIN(  48)					pA = (pA + 1);
HXDLIN(  48)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  48)					pA = (pA + 1);
HXDLIN(  48)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  48)			int pC = _this->pointsClock->length;
HXDLIN(  48)			{
HXDLIN(  48)				int _g4 = 0;
HXDLIN(  48)				int _g5 = p4;
HXDLIN(  48)				while((_g4 < _g5)){
HXDLIN(  48)					_g4 = (_g4 + 1);
HXDLIN(  48)					int i = (_g4 - 1);
HXDLIN(  48)					pC = (pC + 1);
HXDLIN(  48)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  48)					pC = (pC + 1);
HXDLIN(  48)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  48)		{
HXDLIN(  48)			{
HXDLIN(  48)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  48)				int color = -1;
HXDLIN(  48)				if ((color == -1)) {
HXDLIN(  48)					color = _this1->currentColor;
            				}
HXDLIN(  48)				{
HXDLIN(  48)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  48)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  48)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  48)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  48)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  48)			{
HXDLIN(  48)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  48)				int color1 = -1;
HXDLIN(  48)				if ((color1 == -1)) {
HXDLIN(  48)					color1 = _this2->currentColor;
            				}
HXDLIN(  48)				{
HXDLIN(  48)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  48)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  48)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  48)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  48)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
HXDLIN(  48)		if ((_this->count != 0)) {
HXDLIN(  48)			if (clockWise) {
HXDLIN(  48)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  48)				int color = -1;
HXDLIN(  48)				if ((color == -1)) {
HXDLIN(  48)					color = _this1->currentColor;
            				}
HXDLIN(  48)				{
HXDLIN(  48)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  48)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  48)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  48)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  48)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
            			else {
HXDLIN(  48)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  48)				int color = -1;
HXDLIN(  48)				if ((color == -1)) {
HXDLIN(  48)					color = _this1->currentColor;
            				}
HXDLIN(  48)				{
HXDLIN(  48)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  48)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  48)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  48)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  48)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
            		}
HXDLIN(  48)		{
HXDLIN(  48)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  48)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  48)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  48)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  48)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  48)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  48)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  48)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  48)		_this->jxOld = _this->jx;
HXDLIN(  48)		_this->jyOld = _this->jy;
HXDLIN(  48)		_this->lastClock = clockWise;
HXDLIN(  48)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,mediumOverlapLine,(void))

void Sketch_obj::fineLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_51_fineLine)
HXDLIN(  51)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  51)		Float ax_ = this->x;
HXDLIN(  51)		Float ay_ = this->y;
HXDLIN(  51)		Float width_ = this->width;
HXDLIN(  51)		bool overlap = false;
HXDLIN(  51)		 ::Dynamic oldAngle;
HXDLIN(  51)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  51)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  51)			oldAngle = null();
            		}
HXDLIN(  51)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  51)		_this->ax = x_;
HXDLIN(  51)		_this->ay = y_;
HXDLIN(  51)		_this->bx = ax_;
HXDLIN(  51)		_this->by = ay_;
HXDLIN(  51)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  51)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  51)		{
HXDLIN(  51)			{
HXDLIN(  51)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  51)				if ((_this->theta > 0)) {
HXDLIN(  51)					if ((_this->halfA < 0)) {
HXDLIN(  51)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  51)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  51)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  51)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  51)					if ((_this->halfA > 0)) {
HXDLIN(  51)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  51)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  51)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  51)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  51)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  51)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  51)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  51)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  51)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  51)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  51)				_this->exPrev = _this->ex;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  51)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  51)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  51)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  51)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  51)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  51)		_this->ax = ax_;
HXDLIN(  51)		_this->ay = ay_;
HXDLIN(  51)		_this->bx = x_;
HXDLIN(  51)		_this->by = y_;
HXDLIN(  51)		{
HXDLIN(  51)			{
HXDLIN(  51)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  51)				if ((_this->theta > 0)) {
HXDLIN(  51)					if ((_this->halfA < 0)) {
HXDLIN(  51)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  51)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  51)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  51)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  51)					if ((_this->halfA > 0)) {
HXDLIN(  51)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  51)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  51)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  51)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  51)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  51)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  51)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  51)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  51)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  51)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  51)				_this->exPrev = _this->ex;
            			}
HXDLIN(  51)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  51)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  51)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  51)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  51)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  51)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  51)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  51)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  51)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  51)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  51)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  51)		Float theta0;
HXDLIN(  51)		Float theta1;
HXDLIN(  51)		if (clockWise) {
HXDLIN(  51)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  51)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  51)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  51)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  51)		Float dif;
HXDLIN(  51)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  51)				Float f;
HXDLIN(  51)				bool f1;
HXDLIN(  51)				if ((theta0 >= 0)) {
HXDLIN(  51)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  51)					f1 = false;
            				}
HXDLIN(  51)				if (f1) {
HXDLIN(  51)					f = theta0;
            				}
            				else {
HXDLIN(  51)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)					if ((a >= 0)) {
HXDLIN(  51)						f = a;
            					}
            					else {
HXDLIN(  51)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  51)				Float this1 = f;
HXDLIN(  51)				Float za = this1;
HXDLIN(  51)				Float f2;
HXDLIN(  51)				bool f3;
HXDLIN(  51)				if ((theta1 >= 0)) {
HXDLIN(  51)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  51)					f3 = false;
            				}
HXDLIN(  51)				if (f3) {
HXDLIN(  51)					f2 = theta1;
            				}
            				else {
HXDLIN(  51)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)					if ((a >= 0)) {
HXDLIN(  51)						f2 = a;
            					}
            					else {
HXDLIN(  51)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  51)				Float this2 = f2;
HXDLIN(  51)				Float zb = this2;
HXDLIN(  51)				Float fa = za;
HXDLIN(  51)				Float fb = zb;
HXDLIN(  51)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  51)				bool clockwise = (fa < fb);
HXDLIN(  51)				Float dif1;
HXDLIN(  51)				if (clockwise) {
HXDLIN(  51)					dif1 = theta;
            				}
            				else {
HXDLIN(  51)					dif1 = -(theta);
            				}
HXDLIN(  51)				if ((dif1 > 0)) {
HXDLIN(  51)					dif = dif1;
            				}
            				else {
HXDLIN(  51)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  51)				Float f;
HXDLIN(  51)				bool f1;
HXDLIN(  51)				if ((theta0 >= 0)) {
HXDLIN(  51)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  51)					f1 = false;
            				}
HXDLIN(  51)				if (f1) {
HXDLIN(  51)					f = theta0;
            				}
            				else {
HXDLIN(  51)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)					if ((a >= 0)) {
HXDLIN(  51)						f = a;
            					}
            					else {
HXDLIN(  51)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  51)				Float this1 = f;
HXDLIN(  51)				Float za = this1;
HXDLIN(  51)				Float f2;
HXDLIN(  51)				bool f3;
HXDLIN(  51)				if ((theta1 >= 0)) {
HXDLIN(  51)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  51)					f3 = false;
            				}
HXDLIN(  51)				if (f3) {
HXDLIN(  51)					f2 = theta1;
            				}
            				else {
HXDLIN(  51)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)					if ((a >= 0)) {
HXDLIN(  51)						f2 = a;
            					}
            					else {
HXDLIN(  51)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  51)				Float this2 = f2;
HXDLIN(  51)				Float zb = this2;
HXDLIN(  51)				Float fa = za;
HXDLIN(  51)				Float fb = zb;
HXDLIN(  51)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  51)				bool clockwise = (fa < fb);
HXDLIN(  51)				Float dif1;
HXDLIN(  51)				if (clockwise) {
HXDLIN(  51)					dif1 = theta;
            				}
            				else {
HXDLIN(  51)					dif1 = -(theta);
            				}
HXDLIN(  51)				if ((dif1 < 0)) {
HXDLIN(  51)					dif = dif1;
            				}
            				else {
HXDLIN(  51)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  51)				Float f;
HXDLIN(  51)				bool f1;
HXDLIN(  51)				if ((theta0 >= 0)) {
HXDLIN(  51)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  51)					f1 = false;
            				}
HXDLIN(  51)				if (f1) {
HXDLIN(  51)					f = theta0;
            				}
            				else {
HXDLIN(  51)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)					if ((a >= 0)) {
HXDLIN(  51)						f = a;
            					}
            					else {
HXDLIN(  51)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  51)				Float this1 = f;
HXDLIN(  51)				Float za = this1;
HXDLIN(  51)				Float f2;
HXDLIN(  51)				bool f3;
HXDLIN(  51)				if ((theta1 >= 0)) {
HXDLIN(  51)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  51)					f3 = false;
            				}
HXDLIN(  51)				if (f3) {
HXDLIN(  51)					f2 = theta1;
            				}
            				else {
HXDLIN(  51)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)					if ((a >= 0)) {
HXDLIN(  51)						f2 = a;
            					}
            					else {
HXDLIN(  51)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  51)				Float this2 = f2;
HXDLIN(  51)				Float zb = this2;
HXDLIN(  51)				Float fa = za;
HXDLIN(  51)				Float fb = zb;
HXDLIN(  51)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  51)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  51)				bool clockwise = (fa < fb);
HXDLIN(  51)				Float dif1;
HXDLIN(  51)				if (clockwise) {
HXDLIN(  51)					dif1 = theta;
            				}
            				else {
HXDLIN(  51)					dif1 = -(theta);
            				}
HXDLIN(  51)				if (smallest) {
HXDLIN(  51)					dif = dif1;
            				}
            				else {
HXDLIN(  51)					if (clockwise) {
HXDLIN(  51)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  51)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  51)				Float f;
HXDLIN(  51)				bool f1;
HXDLIN(  51)				if ((theta0 >= 0)) {
HXDLIN(  51)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  51)					f1 = false;
            				}
HXDLIN(  51)				if (f1) {
HXDLIN(  51)					f = theta0;
            				}
            				else {
HXDLIN(  51)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)					if ((a >= 0)) {
HXDLIN(  51)						f = a;
            					}
            					else {
HXDLIN(  51)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  51)				Float this1 = f;
HXDLIN(  51)				Float za = this1;
HXDLIN(  51)				Float f2;
HXDLIN(  51)				bool f3;
HXDLIN(  51)				if ((theta1 >= 0)) {
HXDLIN(  51)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  51)					f3 = false;
            				}
HXDLIN(  51)				if (f3) {
HXDLIN(  51)					f2 = theta1;
            				}
            				else {
HXDLIN(  51)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)					if ((a >= 0)) {
HXDLIN(  51)						f2 = a;
            					}
            					else {
HXDLIN(  51)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  51)				Float this2 = f2;
HXDLIN(  51)				Float zb = this2;
HXDLIN(  51)				Float fa = za;
HXDLIN(  51)				Float fb = zb;
HXDLIN(  51)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  51)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  51)				bool clockwise = (fa < fb);
HXDLIN(  51)				Float dif1;
HXDLIN(  51)				if (clockwise) {
HXDLIN(  51)					dif1 = theta;
            				}
            				else {
HXDLIN(  51)					dif1 = -(theta);
            				}
HXDLIN(  51)				if (largest) {
HXDLIN(  51)					dif = dif1;
            				}
            				else {
HXDLIN(  51)					if (clockwise) {
HXDLIN(  51)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  51)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  51)		bool _hx_tmp;
HXDLIN(  51)		if (!(overlap)) {
HXDLIN(  51)			_hx_tmp = (_this->count != 0);
            		}
            		else {
HXDLIN(  51)			_hx_tmp = false;
            		}
HXDLIN(  51)		if (_hx_tmp) {
HXDLIN(  51)			Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXDLIN(  51)			Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXDLIN(  51)			Float f;
HXDLIN(  51)			bool f1;
HXDLIN(  51)			if ((theta0 <= ::Math_obj::PI)) {
HXDLIN(  51)				f1 = (theta0 > -(::Math_obj::PI));
            			}
            			else {
HXDLIN(  51)				f1 = false;
            			}
HXDLIN(  51)			if (f1) {
HXDLIN(  51)				f = theta0;
            			}
            			else {
HXDLIN(  51)				Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)				if ((a >= 0)) {
HXDLIN(  51)					f = (a - ::Math_obj::PI);
            				}
            				else {
HXDLIN(  51)					f = (a + ::Math_obj::PI);
            				}
            			}
HXDLIN(  51)			Float this1 = f;
HXDLIN(  51)			Float start = this1;
HXDLIN(  51)			Float start2 = start;
HXDLIN(  51)			Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  51)			_this->jx = (_this->ax + (h * ::Math_obj::sin(delta)));
HXDLIN(  51)			_this->jy = (_this->ay + (h * ::Math_obj::cos(delta)));
            		}
HXDLIN(  51)		bool _hx_tmp1;
HXDLIN(  51)		if ((_this->count == 0)) {
HXDLIN(  51)			if ((_this->endLine != 1)) {
HXDLIN(  51)				_hx_tmp1 = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  51)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXDLIN(  51)			_hx_tmp1 = false;
            		}
HXDLIN(  51)		if (_hx_tmp1) {
HXDLIN(  51)			Float ax = _this->ax;
HXDLIN(  51)			Float ay = _this->ay;
HXDLIN(  51)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  51)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  51)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  51)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  51)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  51)			 ::Dynamic sides = 36;
HXDLIN(  51)			if (::hx::IsNull( sides )) {
HXDLIN(  51)				sides = 36;
            			}
HXDLIN(  51)			Float pi = ::Math_obj::PI;
HXDLIN(  51)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  51)			Float dif;
HXDLIN(  51)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  51)					Float f;
HXDLIN(  51)					bool f1;
HXDLIN(  51)					if ((beta >= 0)) {
HXDLIN(  51)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  51)						f1 = false;
            					}
HXDLIN(  51)					if (f1) {
HXDLIN(  51)						f = beta;
            					}
            					else {
HXDLIN(  51)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)						if ((a >= 0)) {
HXDLIN(  51)							f = a;
            						}
            						else {
HXDLIN(  51)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  51)					Float this1 = f;
HXDLIN(  51)					Float za = this1;
HXDLIN(  51)					Float f2;
HXDLIN(  51)					bool f3;
HXDLIN(  51)					if ((gamma >= 0)) {
HXDLIN(  51)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  51)						f3 = false;
            					}
HXDLIN(  51)					if (f3) {
HXDLIN(  51)						f2 = gamma;
            					}
            					else {
HXDLIN(  51)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)						if ((a >= 0)) {
HXDLIN(  51)							f2 = a;
            						}
            						else {
HXDLIN(  51)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  51)					Float this2 = f2;
HXDLIN(  51)					Float zb = this2;
HXDLIN(  51)					Float fa = za;
HXDLIN(  51)					Float fb = zb;
HXDLIN(  51)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  51)					bool clockwise = (fa < fb);
HXDLIN(  51)					Float dif1;
HXDLIN(  51)					if (clockwise) {
HXDLIN(  51)						dif1 = theta;
            					}
            					else {
HXDLIN(  51)						dif1 = -(theta);
            					}
HXDLIN(  51)					if ((dif1 > 0)) {
HXDLIN(  51)						dif = dif1;
            					}
            					else {
HXDLIN(  51)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  51)					Float f;
HXDLIN(  51)					bool f1;
HXDLIN(  51)					if ((beta >= 0)) {
HXDLIN(  51)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  51)						f1 = false;
            					}
HXDLIN(  51)					if (f1) {
HXDLIN(  51)						f = beta;
            					}
            					else {
HXDLIN(  51)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)						if ((a >= 0)) {
HXDLIN(  51)							f = a;
            						}
            						else {
HXDLIN(  51)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  51)					Float this1 = f;
HXDLIN(  51)					Float za = this1;
HXDLIN(  51)					Float f2;
HXDLIN(  51)					bool f3;
HXDLIN(  51)					if ((gamma >= 0)) {
HXDLIN(  51)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  51)						f3 = false;
            					}
HXDLIN(  51)					if (f3) {
HXDLIN(  51)						f2 = gamma;
            					}
            					else {
HXDLIN(  51)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)						if ((a >= 0)) {
HXDLIN(  51)							f2 = a;
            						}
            						else {
HXDLIN(  51)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  51)					Float this2 = f2;
HXDLIN(  51)					Float zb = this2;
HXDLIN(  51)					Float fa = za;
HXDLIN(  51)					Float fb = zb;
HXDLIN(  51)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  51)					bool clockwise = (fa < fb);
HXDLIN(  51)					Float dif1;
HXDLIN(  51)					if (clockwise) {
HXDLIN(  51)						dif1 = theta;
            					}
            					else {
HXDLIN(  51)						dif1 = -(theta);
            					}
HXDLIN(  51)					if ((dif1 < 0)) {
HXDLIN(  51)						dif = dif1;
            					}
            					else {
HXDLIN(  51)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  51)					Float f;
HXDLIN(  51)					bool f1;
HXDLIN(  51)					if ((beta >= 0)) {
HXDLIN(  51)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  51)						f1 = false;
            					}
HXDLIN(  51)					if (f1) {
HXDLIN(  51)						f = beta;
            					}
            					else {
HXDLIN(  51)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)						if ((a >= 0)) {
HXDLIN(  51)							f = a;
            						}
            						else {
HXDLIN(  51)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  51)					Float this1 = f;
HXDLIN(  51)					Float za = this1;
HXDLIN(  51)					Float f2;
HXDLIN(  51)					bool f3;
HXDLIN(  51)					if ((gamma >= 0)) {
HXDLIN(  51)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  51)						f3 = false;
            					}
HXDLIN(  51)					if (f3) {
HXDLIN(  51)						f2 = gamma;
            					}
            					else {
HXDLIN(  51)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)						if ((a >= 0)) {
HXDLIN(  51)							f2 = a;
            						}
            						else {
HXDLIN(  51)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  51)					Float this2 = f2;
HXDLIN(  51)					Float zb = this2;
HXDLIN(  51)					Float fa = za;
HXDLIN(  51)					Float fb = zb;
HXDLIN(  51)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  51)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  51)					bool clockwise = (fa < fb);
HXDLIN(  51)					Float dif1;
HXDLIN(  51)					if (clockwise) {
HXDLIN(  51)						dif1 = theta;
            					}
            					else {
HXDLIN(  51)						dif1 = -(theta);
            					}
HXDLIN(  51)					if (smallest) {
HXDLIN(  51)						dif = dif1;
            					}
            					else {
HXDLIN(  51)						if (clockwise) {
HXDLIN(  51)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  51)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  51)					Float f;
HXDLIN(  51)					bool f1;
HXDLIN(  51)					if ((beta >= 0)) {
HXDLIN(  51)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  51)						f1 = false;
            					}
HXDLIN(  51)					if (f1) {
HXDLIN(  51)						f = beta;
            					}
            					else {
HXDLIN(  51)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)						if ((a >= 0)) {
HXDLIN(  51)							f = a;
            						}
            						else {
HXDLIN(  51)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  51)					Float this1 = f;
HXDLIN(  51)					Float za = this1;
HXDLIN(  51)					Float f2;
HXDLIN(  51)					bool f3;
HXDLIN(  51)					if ((gamma >= 0)) {
HXDLIN(  51)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  51)						f3 = false;
            					}
HXDLIN(  51)					if (f3) {
HXDLIN(  51)						f2 = gamma;
            					}
            					else {
HXDLIN(  51)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  51)						if ((a >= 0)) {
HXDLIN(  51)							f2 = a;
            						}
            						else {
HXDLIN(  51)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  51)					Float this2 = f2;
HXDLIN(  51)					Float zb = this2;
HXDLIN(  51)					Float fa = za;
HXDLIN(  51)					Float fb = zb;
HXDLIN(  51)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  51)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  51)					bool clockwise = (fa < fb);
HXDLIN(  51)					Float dif1;
HXDLIN(  51)					if (clockwise) {
HXDLIN(  51)						dif1 = theta;
            					}
            					else {
HXDLIN(  51)						dif1 = -(theta);
            					}
HXDLIN(  51)					if (largest) {
HXDLIN(  51)						dif = dif1;
            					}
            					else {
HXDLIN(  51)						if (clockwise) {
HXDLIN(  51)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  51)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  51)			bool positive = (dif >= 0);
HXDLIN(  51)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  51)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  51)			Float angle = beta;
HXDLIN(  51)			Float cx;
HXDLIN(  51)			Float cy;
HXDLIN(  51)			Float bx = ( (Float)(0) );
HXDLIN(  51)			Float by = ( (Float)(0) );
HXDLIN(  51)			int p2 = temp->length;
HXDLIN(  51)			{
HXDLIN(  51)				int _g = 0;
HXDLIN(  51)				int _g1 = (totalSteps + 1);
HXDLIN(  51)				while((_g < _g1)){
HXDLIN(  51)					_g = (_g + 1);
HXDLIN(  51)					int i = (_g - 1);
HXDLIN(  51)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  51)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  51)					p2 = (p2 + 1);
HXDLIN(  51)					temp[(p2 - 1)] = cx;
HXDLIN(  51)					p2 = (p2 + 1);
HXDLIN(  51)					temp[(p2 - 1)] = cy;
HXDLIN(  51)					if ((i != 0)) {
HXDLIN(  51)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  51)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  51)						if (::hx::IsNotNull( m )) {
HXDLIN(  51)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  51)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  51)					angle = (angle + step1);
HXDLIN(  51)					bx = cx;
HXDLIN(  51)					by = cy;
            				}
            			}
HXDLIN(  51)			int len = totalSteps;
HXDLIN(  51)			{
HXDLIN(  51)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)				int color = -1;
HXDLIN(  51)				if ((color == -1)) {
HXDLIN(  51)					color = _this1->currentColor;
            				}
HXDLIN(  51)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  51)			int pA = _this->pointsAnti->length;
HXDLIN(  51)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  51)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  51)			{
HXDLIN(  51)				int _g2 = 0;
HXDLIN(  51)				int _g3 = p4;
HXDLIN(  51)				while((_g2 < _g3)){
HXDLIN(  51)					_g2 = (_g2 + 1);
HXDLIN(  51)					int i = (_g2 - 1);
HXDLIN(  51)					pA = (pA + 1);
HXDLIN(  51)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  51)					pA = (pA + 1);
HXDLIN(  51)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  51)			int pC = _this->pointsClock->length;
HXDLIN(  51)			{
HXDLIN(  51)				int _g4 = 0;
HXDLIN(  51)				int _g5 = p4;
HXDLIN(  51)				while((_g4 < _g5)){
HXDLIN(  51)					_g4 = (_g4 + 1);
HXDLIN(  51)					int i = (_g4 - 1);
HXDLIN(  51)					pC = (pC + 1);
HXDLIN(  51)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  51)					pC = (pC + 1);
HXDLIN(  51)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  51)		if (overlap) {
HXDLIN(  51)			{
HXDLIN(  51)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)				int color = -1;
HXDLIN(  51)				if ((color == -1)) {
HXDLIN(  51)					color = _this1->currentColor;
            				}
HXDLIN(  51)				{
HXDLIN(  51)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  51)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  51)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  51)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  51)			{
HXDLIN(  51)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  51)				int color1 = -1;
HXDLIN(  51)				if ((color1 == -1)) {
HXDLIN(  51)					color1 = _this2->currentColor;
            				}
HXDLIN(  51)				{
HXDLIN(  51)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  51)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  51)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  51)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            		else {
HXDLIN(  51)			if ((_this->count != 0)) {
HXDLIN(  51)				_this->addQuads(clockWise,width_);
            			}
HXDLIN(  51)			{
HXDLIN(  51)				_this->quadIndex = ( (Float)(_this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
HXDLIN(  51)				if ((_this->count == 0)) {
HXDLIN(  51)					_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  51)					_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  51)					_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  51)					_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  51)					_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  51)					_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  51)					_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  51)					_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  51)					{
HXDLIN(  51)						 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)						int color = -1;
HXDLIN(  51)						if ((color == -1)) {
HXDLIN(  51)							color = _this1->currentColor;
            						}
HXDLIN(  51)						{
HXDLIN(  51)							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  51)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  51)							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  51)						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
HXDLIN(  51)					{
HXDLIN(  51)						 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  51)						int color1 = -1;
HXDLIN(  51)						if ((color1 == -1)) {
HXDLIN(  51)							color1 = _this2->currentColor;
            						}
HXDLIN(  51)						{
HXDLIN(  51)							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  51)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  51)							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  51)						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            					}
            				}
            				else {
HXDLIN(  51)					bool _hx_tmp;
HXDLIN(  51)					if (clockWise) {
HXDLIN(  51)						_hx_tmp = !(_this->lastClock);
            					}
            					else {
HXDLIN(  51)						_hx_tmp = false;
            					}
HXDLIN(  51)					if (_hx_tmp) {
HXDLIN(  51)						_this->penultimateAX = _this->jx;
HXDLIN(  51)						_this->penultimateAY = _this->jy;
HXDLIN(  51)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  51)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  51)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  51)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  51)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  51)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  51)						{
HXDLIN(  51)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)							int color = -1;
HXDLIN(  51)							if ((color == -1)) {
HXDLIN(  51)								color = _this1->currentColor;
            							}
HXDLIN(  51)							{
HXDLIN(  51)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  51)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  51)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  51)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  51)						{
HXDLIN(  51)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  51)							int color1 = -1;
HXDLIN(  51)							if ((color1 == -1)) {
HXDLIN(  51)								color1 = _this2->currentColor;
            							}
HXDLIN(  51)							{
HXDLIN(  51)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  51)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  51)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  51)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  51)					bool _hx_tmp1;
HXDLIN(  51)					if (clockWise) {
HXDLIN(  51)						_hx_tmp1 = _this->lastClock;
            					}
            					else {
HXDLIN(  51)						_hx_tmp1 = false;
            					}
HXDLIN(  51)					if (_hx_tmp1) {
HXDLIN(  51)						_this->penultimateAX = _this->jx;
HXDLIN(  51)						_this->penultimateAY = _this->jy;
HXDLIN(  51)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  51)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  51)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  51)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  51)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  51)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  51)						{
HXDLIN(  51)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)							int color = -1;
HXDLIN(  51)							if ((color == -1)) {
HXDLIN(  51)								color = _this1->currentColor;
            							}
HXDLIN(  51)							{
HXDLIN(  51)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  51)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  51)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  51)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  51)						{
HXDLIN(  51)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  51)							int color1 = -1;
HXDLIN(  51)							if ((color1 == -1)) {
HXDLIN(  51)								color1 = _this2->currentColor;
            							}
HXDLIN(  51)							{
HXDLIN(  51)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  51)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  51)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  51)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  51)					bool _hx_tmp2;
HXDLIN(  51)					if (!(clockWise)) {
HXDLIN(  51)						_hx_tmp2 = !(_this->lastClock);
            					}
            					else {
HXDLIN(  51)						_hx_tmp2 = false;
            					}
HXDLIN(  51)					if (_hx_tmp2) {
HXDLIN(  51)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  51)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  51)						_this->lastClockX = _this->jx;
HXDLIN(  51)						_this->lastClockY = _this->jy;
HXDLIN(  51)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  51)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  51)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  51)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  51)						{
HXDLIN(  51)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)							int color = -1;
HXDLIN(  51)							if ((color == -1)) {
HXDLIN(  51)								color = _this1->currentColor;
            							}
HXDLIN(  51)							{
HXDLIN(  51)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,_this->jx,_this->jy,0);
HXDLIN(  51)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  51)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  51)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  51)						{
HXDLIN(  51)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  51)							int color1 = -1;
HXDLIN(  51)							if ((color1 == -1)) {
HXDLIN(  51)								color1 = _this2->currentColor;
            							}
HXDLIN(  51)							{
HXDLIN(  51)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  51)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  51)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  51)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  51)					bool _hx_tmp3;
HXDLIN(  51)					if (!(clockWise)) {
HXDLIN(  51)						_hx_tmp3 = _this->lastClock;
            					}
            					else {
HXDLIN(  51)						_hx_tmp3 = false;
            					}
HXDLIN(  51)					if (_hx_tmp3) {
HXDLIN(  51)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  51)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  51)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  51)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  51)						_this->penultimateCX = _this->jx;
HXDLIN(  51)						_this->penultimateCY = _this->jy;
HXDLIN(  51)						_this->lastClockX = ( (Float)(_this->dx) );
HXDLIN(  51)						_this->lastClockY = ( (Float)(_this->dy) );
HXDLIN(  51)						{
HXDLIN(  51)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)							int color = -1;
HXDLIN(  51)							if ((color == -1)) {
HXDLIN(  51)								color = _this1->currentColor;
            							}
HXDLIN(  51)							{
HXDLIN(  51)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  51)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  51)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  51)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  51)						{
HXDLIN(  51)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  51)							int color1 = -1;
HXDLIN(  51)							if ((color1 == -1)) {
HXDLIN(  51)								color1 = _this2->currentColor;
            							}
HXDLIN(  51)							{
HXDLIN(  51)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  51)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  51)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  51)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
            				}
            			}
            		}
HXDLIN(  51)		if (clockWise) {
HXDLIN(  51)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  51)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  51)			::Array< Float > edgePoly = _this->pointsClock;
HXDLIN(  51)			Float pi = ::Math_obj::PI;
HXDLIN(  51)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  51)			bool positive = (dif >= 0);
HXDLIN(  51)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  51)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  51)			Float angle = theta0;
HXDLIN(  51)			Float cx;
HXDLIN(  51)			Float cy;
HXDLIN(  51)			Float bx = ( (Float)(0) );
HXDLIN(  51)			Float by = ( (Float)(0) );
HXDLIN(  51)			int p2 = edgePoly->length;
HXDLIN(  51)			{
HXDLIN(  51)				int _g = 0;
HXDLIN(  51)				int _g1 = (totalSteps + 1);
HXDLIN(  51)				while((_g < _g1)){
HXDLIN(  51)					_g = (_g + 1);
HXDLIN(  51)					int i = (_g - 1);
HXDLIN(  51)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  51)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  51)					p2 = (p2 + 1);
HXDLIN(  51)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  51)					p2 = (p2 + 1);
HXDLIN(  51)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  51)					if ((i != 0)) {
HXDLIN(  51)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  51)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  51)						if (::hx::IsNotNull( m )) {
HXDLIN(  51)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  51)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  51)					angle = (angle + step1);
HXDLIN(  51)					bx = cx;
HXDLIN(  51)					by = cy;
            				}
            			}
HXDLIN(  51)			int len = totalSteps;
HXDLIN(  51)			{
HXDLIN(  51)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)				int color = -1;
HXDLIN(  51)				if ((color == -1)) {
HXDLIN(  51)					color = _this1->currentColor;
            				}
HXDLIN(  51)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
            		else {
HXDLIN(  51)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  51)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  51)			::Array< Float > edgePoly = _this->pointsAnti;
HXDLIN(  51)			Float pi = ::Math_obj::PI;
HXDLIN(  51)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  51)			bool positive = (dif >= 0);
HXDLIN(  51)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  51)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  51)			Float angle = theta0;
HXDLIN(  51)			Float cx;
HXDLIN(  51)			Float cy;
HXDLIN(  51)			Float bx = ( (Float)(0) );
HXDLIN(  51)			Float by = ( (Float)(0) );
HXDLIN(  51)			int p2 = edgePoly->length;
HXDLIN(  51)			{
HXDLIN(  51)				int _g = 0;
HXDLIN(  51)				int _g1 = (totalSteps + 1);
HXDLIN(  51)				while((_g < _g1)){
HXDLIN(  51)					_g = (_g + 1);
HXDLIN(  51)					int i = (_g - 1);
HXDLIN(  51)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  51)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  51)					p2 = (p2 + 1);
HXDLIN(  51)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  51)					p2 = (p2 + 1);
HXDLIN(  51)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  51)					if ((i != 0)) {
HXDLIN(  51)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  51)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  51)						if (::hx::IsNotNull( m )) {
HXDLIN(  51)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  51)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  51)					angle = (angle + step1);
HXDLIN(  51)					bx = cx;
HXDLIN(  51)					by = cy;
            				}
            			}
HXDLIN(  51)			int len = totalSteps;
HXDLIN(  51)			{
HXDLIN(  51)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)				int color = -1;
HXDLIN(  51)				if ((color == -1)) {
HXDLIN(  51)					color = _this1->currentColor;
            				}
HXDLIN(  51)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  51)		{
HXDLIN(  51)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  51)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  51)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  51)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  51)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  51)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  51)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  51)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  51)		bool _hx_tmp2;
HXDLIN(  51)		if (!(overlap)) {
HXDLIN(  51)			_hx_tmp2 = (_this->count != 0);
            		}
            		else {
HXDLIN(  51)			_hx_tmp2 = false;
            		}
HXDLIN(  51)		if (_hx_tmp2) {
HXDLIN(  51)			if (clockWise) {
HXDLIN(  51)				{
HXDLIN(  51)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)					int color = -1;
HXDLIN(  51)					if ((color == -1)) {
HXDLIN(  51)						color = _this1->currentColor;
            					}
HXDLIN(  51)					{
HXDLIN(  51)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,_this->jx,_this->jy,0);
HXDLIN(  51)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  51)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  51)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXDLIN(  51)				{
HXDLIN(  51)					 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  51)					int color1 = -1;
HXDLIN(  51)					if ((color1 == -1)) {
HXDLIN(  51)						color1 = _this2->currentColor;
            					}
HXDLIN(  51)					{
HXDLIN(  51)						_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  51)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)							_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  51)						_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  51)					_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            			else {
HXDLIN(  51)				{
HXDLIN(  51)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  51)					int color = -1;
HXDLIN(  51)					if ((color == -1)) {
HXDLIN(  51)						color = _this1->currentColor;
            					}
HXDLIN(  51)					{
HXDLIN(  51)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,_this->jx,_this->jy,0);
HXDLIN(  51)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  51)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  51)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXDLIN(  51)				{
HXDLIN(  51)					 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  51)					int color1 = -1;
HXDLIN(  51)					if ((color1 == -1)) {
HXDLIN(  51)						color1 = _this2->currentColor;
            					}
HXDLIN(  51)					{
HXDLIN(  51)						_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  51)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  51)							_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  51)						_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  51)					_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            		}
HXDLIN(  51)		_this->jxOld = _this->jx;
HXDLIN(  51)		_this->jyOld = _this->jy;
HXDLIN(  51)		_this->lastClock = clockWise;
HXDLIN(  51)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fineLine,(void))

void Sketch_obj::fineOverlapLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_54_fineOverlapLine)
HXDLIN(  54)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  54)		Float ax_ = this->x;
HXDLIN(  54)		Float ay_ = this->y;
HXDLIN(  54)		Float width_ = this->width;
HXDLIN(  54)		 ::Dynamic oldAngle;
HXDLIN(  54)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  54)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  54)			oldAngle = null();
            		}
HXDLIN(  54)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  54)		_this->ax = x_;
HXDLIN(  54)		_this->ay = y_;
HXDLIN(  54)		_this->bx = ax_;
HXDLIN(  54)		_this->by = ay_;
HXDLIN(  54)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  54)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  54)		{
HXDLIN(  54)			{
HXDLIN(  54)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  54)				if ((_this->theta > 0)) {
HXDLIN(  54)					if ((_this->halfA < 0)) {
HXDLIN(  54)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  54)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  54)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  54)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  54)					if ((_this->halfA > 0)) {
HXDLIN(  54)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  54)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  54)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  54)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  54)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  54)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  54)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  54)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  54)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  54)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  54)				_this->exPrev = _this->ex;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  54)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  54)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  54)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  54)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  54)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  54)		_this->ax = ax_;
HXDLIN(  54)		_this->ay = ay_;
HXDLIN(  54)		_this->bx = x_;
HXDLIN(  54)		_this->by = y_;
HXDLIN(  54)		{
HXDLIN(  54)			{
HXDLIN(  54)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  54)				if ((_this->theta > 0)) {
HXDLIN(  54)					if ((_this->halfA < 0)) {
HXDLIN(  54)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  54)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  54)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  54)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  54)					if ((_this->halfA > 0)) {
HXDLIN(  54)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  54)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  54)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  54)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  54)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  54)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  54)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  54)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  54)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  54)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  54)				_this->exPrev = _this->ex;
            			}
HXDLIN(  54)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  54)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  54)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  54)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  54)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  54)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  54)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  54)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  54)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  54)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  54)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  54)		Float theta0;
HXDLIN(  54)		Float theta1;
HXDLIN(  54)		if (clockWise) {
HXDLIN(  54)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  54)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  54)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  54)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  54)		Float dif;
HXDLIN(  54)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  54)				Float f;
HXDLIN(  54)				bool f1;
HXDLIN(  54)				if ((theta0 >= 0)) {
HXDLIN(  54)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  54)					f1 = false;
            				}
HXDLIN(  54)				if (f1) {
HXDLIN(  54)					f = theta0;
            				}
            				else {
HXDLIN(  54)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)					if ((a >= 0)) {
HXDLIN(  54)						f = a;
            					}
            					else {
HXDLIN(  54)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  54)				Float this1 = f;
HXDLIN(  54)				Float za = this1;
HXDLIN(  54)				Float f2;
HXDLIN(  54)				bool f3;
HXDLIN(  54)				if ((theta1 >= 0)) {
HXDLIN(  54)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  54)					f3 = false;
            				}
HXDLIN(  54)				if (f3) {
HXDLIN(  54)					f2 = theta1;
            				}
            				else {
HXDLIN(  54)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)					if ((a >= 0)) {
HXDLIN(  54)						f2 = a;
            					}
            					else {
HXDLIN(  54)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  54)				Float this2 = f2;
HXDLIN(  54)				Float zb = this2;
HXDLIN(  54)				Float fa = za;
HXDLIN(  54)				Float fb = zb;
HXDLIN(  54)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  54)				bool clockwise = (fa < fb);
HXDLIN(  54)				Float dif1;
HXDLIN(  54)				if (clockwise) {
HXDLIN(  54)					dif1 = theta;
            				}
            				else {
HXDLIN(  54)					dif1 = -(theta);
            				}
HXDLIN(  54)				if ((dif1 > 0)) {
HXDLIN(  54)					dif = dif1;
            				}
            				else {
HXDLIN(  54)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  54)				Float f;
HXDLIN(  54)				bool f1;
HXDLIN(  54)				if ((theta0 >= 0)) {
HXDLIN(  54)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  54)					f1 = false;
            				}
HXDLIN(  54)				if (f1) {
HXDLIN(  54)					f = theta0;
            				}
            				else {
HXDLIN(  54)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)					if ((a >= 0)) {
HXDLIN(  54)						f = a;
            					}
            					else {
HXDLIN(  54)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  54)				Float this1 = f;
HXDLIN(  54)				Float za = this1;
HXDLIN(  54)				Float f2;
HXDLIN(  54)				bool f3;
HXDLIN(  54)				if ((theta1 >= 0)) {
HXDLIN(  54)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  54)					f3 = false;
            				}
HXDLIN(  54)				if (f3) {
HXDLIN(  54)					f2 = theta1;
            				}
            				else {
HXDLIN(  54)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)					if ((a >= 0)) {
HXDLIN(  54)						f2 = a;
            					}
            					else {
HXDLIN(  54)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  54)				Float this2 = f2;
HXDLIN(  54)				Float zb = this2;
HXDLIN(  54)				Float fa = za;
HXDLIN(  54)				Float fb = zb;
HXDLIN(  54)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  54)				bool clockwise = (fa < fb);
HXDLIN(  54)				Float dif1;
HXDLIN(  54)				if (clockwise) {
HXDLIN(  54)					dif1 = theta;
            				}
            				else {
HXDLIN(  54)					dif1 = -(theta);
            				}
HXDLIN(  54)				if ((dif1 < 0)) {
HXDLIN(  54)					dif = dif1;
            				}
            				else {
HXDLIN(  54)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  54)				Float f;
HXDLIN(  54)				bool f1;
HXDLIN(  54)				if ((theta0 >= 0)) {
HXDLIN(  54)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  54)					f1 = false;
            				}
HXDLIN(  54)				if (f1) {
HXDLIN(  54)					f = theta0;
            				}
            				else {
HXDLIN(  54)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)					if ((a >= 0)) {
HXDLIN(  54)						f = a;
            					}
            					else {
HXDLIN(  54)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  54)				Float this1 = f;
HXDLIN(  54)				Float za = this1;
HXDLIN(  54)				Float f2;
HXDLIN(  54)				bool f3;
HXDLIN(  54)				if ((theta1 >= 0)) {
HXDLIN(  54)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  54)					f3 = false;
            				}
HXDLIN(  54)				if (f3) {
HXDLIN(  54)					f2 = theta1;
            				}
            				else {
HXDLIN(  54)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)					if ((a >= 0)) {
HXDLIN(  54)						f2 = a;
            					}
            					else {
HXDLIN(  54)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  54)				Float this2 = f2;
HXDLIN(  54)				Float zb = this2;
HXDLIN(  54)				Float fa = za;
HXDLIN(  54)				Float fb = zb;
HXDLIN(  54)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  54)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  54)				bool clockwise = (fa < fb);
HXDLIN(  54)				Float dif1;
HXDLIN(  54)				if (clockwise) {
HXDLIN(  54)					dif1 = theta;
            				}
            				else {
HXDLIN(  54)					dif1 = -(theta);
            				}
HXDLIN(  54)				if (smallest) {
HXDLIN(  54)					dif = dif1;
            				}
            				else {
HXDLIN(  54)					if (clockwise) {
HXDLIN(  54)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  54)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  54)				Float f;
HXDLIN(  54)				bool f1;
HXDLIN(  54)				if ((theta0 >= 0)) {
HXDLIN(  54)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  54)					f1 = false;
            				}
HXDLIN(  54)				if (f1) {
HXDLIN(  54)					f = theta0;
            				}
            				else {
HXDLIN(  54)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)					if ((a >= 0)) {
HXDLIN(  54)						f = a;
            					}
            					else {
HXDLIN(  54)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  54)				Float this1 = f;
HXDLIN(  54)				Float za = this1;
HXDLIN(  54)				Float f2;
HXDLIN(  54)				bool f3;
HXDLIN(  54)				if ((theta1 >= 0)) {
HXDLIN(  54)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  54)					f3 = false;
            				}
HXDLIN(  54)				if (f3) {
HXDLIN(  54)					f2 = theta1;
            				}
            				else {
HXDLIN(  54)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)					if ((a >= 0)) {
HXDLIN(  54)						f2 = a;
            					}
            					else {
HXDLIN(  54)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  54)				Float this2 = f2;
HXDLIN(  54)				Float zb = this2;
HXDLIN(  54)				Float fa = za;
HXDLIN(  54)				Float fb = zb;
HXDLIN(  54)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  54)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  54)				bool clockwise = (fa < fb);
HXDLIN(  54)				Float dif1;
HXDLIN(  54)				if (clockwise) {
HXDLIN(  54)					dif1 = theta;
            				}
            				else {
HXDLIN(  54)					dif1 = -(theta);
            				}
HXDLIN(  54)				if (largest) {
HXDLIN(  54)					dif = dif1;
            				}
            				else {
HXDLIN(  54)					if (clockwise) {
HXDLIN(  54)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  54)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  54)		bool _hx_tmp;
HXDLIN(  54)		if ((_this->count == 0)) {
HXDLIN(  54)			if ((_this->endLine != 1)) {
HXDLIN(  54)				_hx_tmp = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  54)				_hx_tmp = true;
            			}
            		}
            		else {
HXDLIN(  54)			_hx_tmp = false;
            		}
HXDLIN(  54)		if (_hx_tmp) {
HXDLIN(  54)			Float ax = _this->ax;
HXDLIN(  54)			Float ay = _this->ay;
HXDLIN(  54)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  54)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  54)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  54)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  54)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  54)			 ::Dynamic sides = 36;
HXDLIN(  54)			if (::hx::IsNull( sides )) {
HXDLIN(  54)				sides = 36;
            			}
HXDLIN(  54)			Float pi = ::Math_obj::PI;
HXDLIN(  54)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  54)			Float dif;
HXDLIN(  54)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  54)					Float f;
HXDLIN(  54)					bool f1;
HXDLIN(  54)					if ((beta >= 0)) {
HXDLIN(  54)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  54)						f1 = false;
            					}
HXDLIN(  54)					if (f1) {
HXDLIN(  54)						f = beta;
            					}
            					else {
HXDLIN(  54)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)						if ((a >= 0)) {
HXDLIN(  54)							f = a;
            						}
            						else {
HXDLIN(  54)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  54)					Float this1 = f;
HXDLIN(  54)					Float za = this1;
HXDLIN(  54)					Float f2;
HXDLIN(  54)					bool f3;
HXDLIN(  54)					if ((gamma >= 0)) {
HXDLIN(  54)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  54)						f3 = false;
            					}
HXDLIN(  54)					if (f3) {
HXDLIN(  54)						f2 = gamma;
            					}
            					else {
HXDLIN(  54)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)						if ((a >= 0)) {
HXDLIN(  54)							f2 = a;
            						}
            						else {
HXDLIN(  54)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  54)					Float this2 = f2;
HXDLIN(  54)					Float zb = this2;
HXDLIN(  54)					Float fa = za;
HXDLIN(  54)					Float fb = zb;
HXDLIN(  54)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  54)					bool clockwise = (fa < fb);
HXDLIN(  54)					Float dif1;
HXDLIN(  54)					if (clockwise) {
HXDLIN(  54)						dif1 = theta;
            					}
            					else {
HXDLIN(  54)						dif1 = -(theta);
            					}
HXDLIN(  54)					if ((dif1 > 0)) {
HXDLIN(  54)						dif = dif1;
            					}
            					else {
HXDLIN(  54)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  54)					Float f;
HXDLIN(  54)					bool f1;
HXDLIN(  54)					if ((beta >= 0)) {
HXDLIN(  54)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  54)						f1 = false;
            					}
HXDLIN(  54)					if (f1) {
HXDLIN(  54)						f = beta;
            					}
            					else {
HXDLIN(  54)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)						if ((a >= 0)) {
HXDLIN(  54)							f = a;
            						}
            						else {
HXDLIN(  54)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  54)					Float this1 = f;
HXDLIN(  54)					Float za = this1;
HXDLIN(  54)					Float f2;
HXDLIN(  54)					bool f3;
HXDLIN(  54)					if ((gamma >= 0)) {
HXDLIN(  54)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  54)						f3 = false;
            					}
HXDLIN(  54)					if (f3) {
HXDLIN(  54)						f2 = gamma;
            					}
            					else {
HXDLIN(  54)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)						if ((a >= 0)) {
HXDLIN(  54)							f2 = a;
            						}
            						else {
HXDLIN(  54)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  54)					Float this2 = f2;
HXDLIN(  54)					Float zb = this2;
HXDLIN(  54)					Float fa = za;
HXDLIN(  54)					Float fb = zb;
HXDLIN(  54)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  54)					bool clockwise = (fa < fb);
HXDLIN(  54)					Float dif1;
HXDLIN(  54)					if (clockwise) {
HXDLIN(  54)						dif1 = theta;
            					}
            					else {
HXDLIN(  54)						dif1 = -(theta);
            					}
HXDLIN(  54)					if ((dif1 < 0)) {
HXDLIN(  54)						dif = dif1;
            					}
            					else {
HXDLIN(  54)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  54)					Float f;
HXDLIN(  54)					bool f1;
HXDLIN(  54)					if ((beta >= 0)) {
HXDLIN(  54)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  54)						f1 = false;
            					}
HXDLIN(  54)					if (f1) {
HXDLIN(  54)						f = beta;
            					}
            					else {
HXDLIN(  54)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)						if ((a >= 0)) {
HXDLIN(  54)							f = a;
            						}
            						else {
HXDLIN(  54)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  54)					Float this1 = f;
HXDLIN(  54)					Float za = this1;
HXDLIN(  54)					Float f2;
HXDLIN(  54)					bool f3;
HXDLIN(  54)					if ((gamma >= 0)) {
HXDLIN(  54)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  54)						f3 = false;
            					}
HXDLIN(  54)					if (f3) {
HXDLIN(  54)						f2 = gamma;
            					}
            					else {
HXDLIN(  54)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)						if ((a >= 0)) {
HXDLIN(  54)							f2 = a;
            						}
            						else {
HXDLIN(  54)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  54)					Float this2 = f2;
HXDLIN(  54)					Float zb = this2;
HXDLIN(  54)					Float fa = za;
HXDLIN(  54)					Float fb = zb;
HXDLIN(  54)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  54)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  54)					bool clockwise = (fa < fb);
HXDLIN(  54)					Float dif1;
HXDLIN(  54)					if (clockwise) {
HXDLIN(  54)						dif1 = theta;
            					}
            					else {
HXDLIN(  54)						dif1 = -(theta);
            					}
HXDLIN(  54)					if (smallest) {
HXDLIN(  54)						dif = dif1;
            					}
            					else {
HXDLIN(  54)						if (clockwise) {
HXDLIN(  54)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  54)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  54)					Float f;
HXDLIN(  54)					bool f1;
HXDLIN(  54)					if ((beta >= 0)) {
HXDLIN(  54)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  54)						f1 = false;
            					}
HXDLIN(  54)					if (f1) {
HXDLIN(  54)						f = beta;
            					}
            					else {
HXDLIN(  54)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)						if ((a >= 0)) {
HXDLIN(  54)							f = a;
            						}
            						else {
HXDLIN(  54)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  54)					Float this1 = f;
HXDLIN(  54)					Float za = this1;
HXDLIN(  54)					Float f2;
HXDLIN(  54)					bool f3;
HXDLIN(  54)					if ((gamma >= 0)) {
HXDLIN(  54)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  54)						f3 = false;
            					}
HXDLIN(  54)					if (f3) {
HXDLIN(  54)						f2 = gamma;
            					}
            					else {
HXDLIN(  54)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  54)						if ((a >= 0)) {
HXDLIN(  54)							f2 = a;
            						}
            						else {
HXDLIN(  54)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  54)					Float this2 = f2;
HXDLIN(  54)					Float zb = this2;
HXDLIN(  54)					Float fa = za;
HXDLIN(  54)					Float fb = zb;
HXDLIN(  54)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  54)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  54)					bool clockwise = (fa < fb);
HXDLIN(  54)					Float dif1;
HXDLIN(  54)					if (clockwise) {
HXDLIN(  54)						dif1 = theta;
            					}
            					else {
HXDLIN(  54)						dif1 = -(theta);
            					}
HXDLIN(  54)					if (largest) {
HXDLIN(  54)						dif = dif1;
            					}
            					else {
HXDLIN(  54)						if (clockwise) {
HXDLIN(  54)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  54)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  54)			bool positive = (dif >= 0);
HXDLIN(  54)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  54)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  54)			Float angle = beta;
HXDLIN(  54)			Float cx;
HXDLIN(  54)			Float cy;
HXDLIN(  54)			Float bx = ( (Float)(0) );
HXDLIN(  54)			Float by = ( (Float)(0) );
HXDLIN(  54)			int p2 = temp->length;
HXDLIN(  54)			{
HXDLIN(  54)				int _g = 0;
HXDLIN(  54)				int _g1 = (totalSteps + 1);
HXDLIN(  54)				while((_g < _g1)){
HXDLIN(  54)					_g = (_g + 1);
HXDLIN(  54)					int i = (_g - 1);
HXDLIN(  54)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  54)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  54)					p2 = (p2 + 1);
HXDLIN(  54)					temp[(p2 - 1)] = cx;
HXDLIN(  54)					p2 = (p2 + 1);
HXDLIN(  54)					temp[(p2 - 1)] = cy;
HXDLIN(  54)					if ((i != 0)) {
HXDLIN(  54)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  54)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  54)						if (::hx::IsNotNull( m )) {
HXDLIN(  54)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  54)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  54)					angle = (angle + step1);
HXDLIN(  54)					bx = cx;
HXDLIN(  54)					by = cy;
            				}
            			}
HXDLIN(  54)			int len = totalSteps;
HXDLIN(  54)			{
HXDLIN(  54)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  54)				int color = -1;
HXDLIN(  54)				if ((color == -1)) {
HXDLIN(  54)					color = _this1->currentColor;
            				}
HXDLIN(  54)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  54)			int pA = _this->pointsAnti->length;
HXDLIN(  54)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  54)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  54)			{
HXDLIN(  54)				int _g2 = 0;
HXDLIN(  54)				int _g3 = p4;
HXDLIN(  54)				while((_g2 < _g3)){
HXDLIN(  54)					_g2 = (_g2 + 1);
HXDLIN(  54)					int i = (_g2 - 1);
HXDLIN(  54)					pA = (pA + 1);
HXDLIN(  54)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  54)					pA = (pA + 1);
HXDLIN(  54)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  54)			int pC = _this->pointsClock->length;
HXDLIN(  54)			{
HXDLIN(  54)				int _g4 = 0;
HXDLIN(  54)				int _g5 = p4;
HXDLIN(  54)				while((_g4 < _g5)){
HXDLIN(  54)					_g4 = (_g4 + 1);
HXDLIN(  54)					int i = (_g4 - 1);
HXDLIN(  54)					pC = (pC + 1);
HXDLIN(  54)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  54)					pC = (pC + 1);
HXDLIN(  54)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  54)		{
HXDLIN(  54)			{
HXDLIN(  54)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  54)				int color = -1;
HXDLIN(  54)				if ((color == -1)) {
HXDLIN(  54)					color = _this1->currentColor;
            				}
HXDLIN(  54)				{
HXDLIN(  54)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  54)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  54)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  54)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  54)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  54)			{
HXDLIN(  54)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  54)				int color1 = -1;
HXDLIN(  54)				if ((color1 == -1)) {
HXDLIN(  54)					color1 = _this2->currentColor;
            				}
HXDLIN(  54)				{
HXDLIN(  54)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  54)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  54)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  54)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  54)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
HXDLIN(  54)		if (clockWise) {
HXDLIN(  54)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  54)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  54)			::Array< Float > edgePoly = _this->pointsClock;
HXDLIN(  54)			Float pi = ::Math_obj::PI;
HXDLIN(  54)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  54)			bool positive = (dif >= 0);
HXDLIN(  54)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  54)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  54)			Float angle = theta0;
HXDLIN(  54)			Float cx;
HXDLIN(  54)			Float cy;
HXDLIN(  54)			Float bx = ( (Float)(0) );
HXDLIN(  54)			Float by = ( (Float)(0) );
HXDLIN(  54)			int p2 = edgePoly->length;
HXDLIN(  54)			{
HXDLIN(  54)				int _g = 0;
HXDLIN(  54)				int _g1 = (totalSteps + 1);
HXDLIN(  54)				while((_g < _g1)){
HXDLIN(  54)					_g = (_g + 1);
HXDLIN(  54)					int i = (_g - 1);
HXDLIN(  54)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  54)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  54)					p2 = (p2 + 1);
HXDLIN(  54)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  54)					p2 = (p2 + 1);
HXDLIN(  54)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  54)					if ((i != 0)) {
HXDLIN(  54)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  54)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  54)						if (::hx::IsNotNull( m )) {
HXDLIN(  54)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  54)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  54)					angle = (angle + step1);
HXDLIN(  54)					bx = cx;
HXDLIN(  54)					by = cy;
            				}
            			}
HXDLIN(  54)			int len = totalSteps;
HXDLIN(  54)			{
HXDLIN(  54)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  54)				int color = -1;
HXDLIN(  54)				if ((color == -1)) {
HXDLIN(  54)					color = _this1->currentColor;
            				}
HXDLIN(  54)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
            		else {
HXDLIN(  54)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  54)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  54)			::Array< Float > edgePoly = _this->pointsAnti;
HXDLIN(  54)			Float pi = ::Math_obj::PI;
HXDLIN(  54)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  54)			bool positive = (dif >= 0);
HXDLIN(  54)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  54)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  54)			Float angle = theta0;
HXDLIN(  54)			Float cx;
HXDLIN(  54)			Float cy;
HXDLIN(  54)			Float bx = ( (Float)(0) );
HXDLIN(  54)			Float by = ( (Float)(0) );
HXDLIN(  54)			int p2 = edgePoly->length;
HXDLIN(  54)			{
HXDLIN(  54)				int _g = 0;
HXDLIN(  54)				int _g1 = (totalSteps + 1);
HXDLIN(  54)				while((_g < _g1)){
HXDLIN(  54)					_g = (_g + 1);
HXDLIN(  54)					int i = (_g - 1);
HXDLIN(  54)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  54)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  54)					p2 = (p2 + 1);
HXDLIN(  54)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  54)					p2 = (p2 + 1);
HXDLIN(  54)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  54)					if ((i != 0)) {
HXDLIN(  54)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  54)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  54)						if (::hx::IsNotNull( m )) {
HXDLIN(  54)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  54)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  54)					angle = (angle + step1);
HXDLIN(  54)					bx = cx;
HXDLIN(  54)					by = cy;
            				}
            			}
HXDLIN(  54)			int len = totalSteps;
HXDLIN(  54)			{
HXDLIN(  54)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  54)				int color = -1;
HXDLIN(  54)				if ((color == -1)) {
HXDLIN(  54)					color = _this1->currentColor;
            				}
HXDLIN(  54)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  54)		{
HXDLIN(  54)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  54)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  54)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  54)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  54)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  54)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  54)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  54)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  54)		_this->jxOld = _this->jx;
HXDLIN(  54)		_this->jyOld = _this->jy;
HXDLIN(  54)		_this->lastClock = clockWise;
HXDLIN(  54)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fineOverlapLine,(void))

void Sketch_obj::reset(){
            	HX_GC_STACKFRAME(&_hx_pos_6351d8d914bc61da_90_reset)
HXLINE(  92)		this->contour =  ::trilateral3::drawing::Contour_obj::__alloc( HX_CTX ,this->pen,this->endLine);
HXLINE(  93)		this->points = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  94)		this->pointsClock = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  95)		this->pointsAnti = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  96)		this->points[0] = ::Array_obj< Float >::__new();
HXLINE(  97)		this->dim = ::Array_obj< ::Dynamic>::__new();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,reset,(void))

::Array< ::Dynamic> Sketch_obj::pointsNoEndOverlap(){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_99_pointsNoEndOverlap)
HXLINE( 100)		::Array< Float > p;
HXLINE( 101)		int l;
HXLINE( 102)		int j = 0;
HXLINE( 103)		::Array< ::Dynamic> pointsClean = ::Array_obj< ::Dynamic>::__new();
HXLINE( 104)		{
HXLINE( 104)			int _g = 0;
HXDLIN( 104)			int _g1 = this->points->length;
HXDLIN( 104)			while((_g < _g1)){
HXLINE( 104)				_g = (_g + 1);
HXDLIN( 104)				int i = (_g - 1);
HXLINE( 105)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 106)				if ((p->length > 2)) {
HXLINE( 106)					j = (j + 1);
HXDLIN( 106)					pointsClean[(j - 1)] = p;
            				}
            			}
            		}
HXLINE( 108)		this->points = pointsClean;
HXLINE( 109)		{
HXLINE( 109)			int _g2 = 0;
HXDLIN( 109)			int _g3 = this->points->length;
HXDLIN( 109)			while((_g2 < _g3)){
HXLINE( 109)				_g2 = (_g2 + 1);
HXDLIN( 109)				int i = (_g2 - 1);
HXLINE( 110)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 111)				l = p->length;
HXLINE( 112)				bool repeat;
HXDLIN( 112)				if ((p->__get(0) == p->__get((l - 2)))) {
HXLINE( 112)					repeat = (p->__get(1) == p->__get((l - 1)));
            				}
            				else {
HXLINE( 112)					repeat = false;
            				}
HXLINE( 113)				if (repeat) {
HXLINE( 114)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 115)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 116)					l = (l - 2);
            				}
            			}
            		}
HXLINE( 151)		return this->points;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,pointsNoEndOverlap,return )

::Array< ::Dynamic> Sketch_obj::pointsRewound(){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_153_pointsRewound)
HXLINE( 154)		::Array< Float > p;
HXLINE( 155)		int l;
HXLINE( 156)		int j = 0;
HXLINE( 157)		::Array< ::Dynamic> pointsClean = ::Array_obj< ::Dynamic>::__new();
HXLINE( 158)		{
HXLINE( 158)			int _g = 0;
HXDLIN( 158)			int _g1 = this->points->length;
HXDLIN( 158)			while((_g < _g1)){
HXLINE( 158)				_g = (_g + 1);
HXDLIN( 158)				int i = (_g - 1);
HXLINE( 159)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 160)				if ((p->length > 2)) {
HXLINE( 160)					j = (j + 1);
HXDLIN( 160)					pointsClean[(j - 1)] = p;
            				}
            			}
            		}
HXLINE( 162)		this->points = pointsClean;
HXLINE( 164)		{
HXLINE( 164)			int _g2 = 0;
HXDLIN( 164)			int _g3 = this->points->length;
HXDLIN( 164)			while((_g2 < _g3)){
HXLINE( 164)				_g2 = (_g2 + 1);
HXDLIN( 164)				int i = (_g2 - 1);
HXLINE( 165)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 166)				l = p->length;
HXLINE( 168)				bool repeat;
HXDLIN( 168)				if ((p->__get(0) == p->__get((l - 2)))) {
HXLINE( 168)					repeat = (p->__get(1) == p->__get((l - 1)));
            				}
            				else {
HXLINE( 168)					repeat = false;
            				}
HXLINE( 169)				if (repeat) {
HXLINE( 170)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 171)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 172)					l = (l - 2);
            				}
HXLINE( 175)				Float cc = ((Float)0.);
HXLINE( 176)				int k = 0;
HXLINE( 177)				Float x1;
HXLINE( 178)				Float y1;
HXLINE( 179)				Float x2;
HXLINE( 180)				Float y2;
HXLINE( 181)				int last = (l - 2);
HXLINE( 182)				while((k < l)){
HXLINE( 183)					x1 = p->__get(k);
HXLINE( 184)					y1 = p->__get((k + 1));
HXLINE( 185)					if ((k == last)) {
HXLINE( 186)						x2 = p->__get(0);
HXLINE( 187)						y2 = p->__get(1);
            					}
            					else {
HXLINE( 189)						x2 = p->__get((k + 2));
HXLINE( 190)						y2 = p->__get((k + 3));
            					}
HXLINE( 192)					cc = (cc + ((x2 - x1) * (y2 + y1)));
HXLINE( 193)					k = (k + 2);
            				}
HXLINE( 208)				this->points[i] = p;
            			}
            		}
HXLINE( 210)		return this->points;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,pointsRewound,return )

 ::Dynamic Sketch_obj::initDim(){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_214_initDim)
HXDLIN( 214)		return  ::Dynamic(::hx::Anon_obj::Create(4)
            			->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            			->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,initDim,return )

void Sketch_obj::updateDim(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_216_updateDim)
HXLINE( 217)		 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXLINE( 218)		if (::hx::IsLess( x,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 218)			d->__SetField(HX_("minX",86,4e,5c,48),x,::hx::paccDynamic);
            		}
HXLINE( 219)		if (::hx::IsGreater( x,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 219)			d->__SetField(HX_("maxX",34,45,56,48),x,::hx::paccDynamic);
            		}
HXLINE( 220)		if (::hx::IsLess( y,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 220)			d->__SetField(HX_("minY",87,4e,5c,48),y,::hx::paccDynamic);
            		}
HXLINE( 221)		if (::hx::IsGreater( y,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 221)			d->__SetField(HX_("maxY",35,45,56,48),y,::hx::paccDynamic);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,updateDim,(void))

void Sketch_obj::moveTo(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_223_moveTo)
HXLINE( 224)		bool _hx_tmp;
HXDLIN( 224)		if ((this->endLine != 2)) {
HXLINE( 224)			_hx_tmp = (this->endLine == 3);
            		}
            		else {
HXLINE( 224)			_hx_tmp = true;
            		}
HXDLIN( 224)		if (_hx_tmp) {
HXLINE( 224)			 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN( 224)			Float width_ = this->width;
HXDLIN( 224)			_this->endEdges();
HXDLIN( 224)			if ((_this->count != 0)) {
HXLINE( 224)				Float ax = _this->bx;
HXDLIN( 224)				Float ay = _this->by;
HXDLIN( 224)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 224)				Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 224)				Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 224)				::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 224)				 ::Dynamic drawType = _this->pen->drawType;
HXDLIN( 224)				 ::Dynamic sides = 36;
HXDLIN( 224)				if (::hx::IsNull( sides )) {
HXLINE( 224)					sides = 36;
            				}
HXDLIN( 224)				Float pi = ::Math_obj::PI;
HXDLIN( 224)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 224)				Float dif;
HXDLIN( 224)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE( 224)						Float f;
HXDLIN( 224)						bool f1;
HXDLIN( 224)						if ((beta >= 0)) {
HXLINE( 224)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 224)							f1 = false;
            						}
HXDLIN( 224)						if (f1) {
HXLINE( 224)							f = beta;
            						}
            						else {
HXLINE( 224)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 224)							if ((a >= 0)) {
HXLINE( 224)								f = a;
            							}
            							else {
HXLINE( 224)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 224)						Float this1 = f;
HXDLIN( 224)						Float za = this1;
HXDLIN( 224)						Float f2;
HXDLIN( 224)						bool f3;
HXDLIN( 224)						if ((gamma >= 0)) {
HXLINE( 224)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 224)							f3 = false;
            						}
HXDLIN( 224)						if (f3) {
HXLINE( 224)							f2 = gamma;
            						}
            						else {
HXLINE( 224)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 224)							if ((a >= 0)) {
HXLINE( 224)								f2 = a;
            							}
            							else {
HXLINE( 224)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 224)						Float this2 = f2;
HXDLIN( 224)						Float zb = this2;
HXDLIN( 224)						Float fa = za;
HXDLIN( 224)						Float fb = zb;
HXDLIN( 224)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 224)						bool clockwise = (fa < fb);
HXDLIN( 224)						Float dif1;
HXDLIN( 224)						if (clockwise) {
HXLINE( 224)							dif1 = theta;
            						}
            						else {
HXLINE( 224)							dif1 = -(theta);
            						}
HXDLIN( 224)						if ((dif1 > 0)) {
HXLINE( 224)							dif = dif1;
            						}
            						else {
HXLINE( 224)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 224)						Float f;
HXDLIN( 224)						bool f1;
HXDLIN( 224)						if ((beta >= 0)) {
HXLINE( 224)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 224)							f1 = false;
            						}
HXDLIN( 224)						if (f1) {
HXLINE( 224)							f = beta;
            						}
            						else {
HXLINE( 224)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 224)							if ((a >= 0)) {
HXLINE( 224)								f = a;
            							}
            							else {
HXLINE( 224)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 224)						Float this1 = f;
HXDLIN( 224)						Float za = this1;
HXDLIN( 224)						Float f2;
HXDLIN( 224)						bool f3;
HXDLIN( 224)						if ((gamma >= 0)) {
HXLINE( 224)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 224)							f3 = false;
            						}
HXDLIN( 224)						if (f3) {
HXLINE( 224)							f2 = gamma;
            						}
            						else {
HXLINE( 224)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 224)							if ((a >= 0)) {
HXLINE( 224)								f2 = a;
            							}
            							else {
HXLINE( 224)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 224)						Float this2 = f2;
HXDLIN( 224)						Float zb = this2;
HXDLIN( 224)						Float fa = za;
HXDLIN( 224)						Float fb = zb;
HXDLIN( 224)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 224)						bool clockwise = (fa < fb);
HXDLIN( 224)						Float dif1;
HXDLIN( 224)						if (clockwise) {
HXLINE( 224)							dif1 = theta;
            						}
            						else {
HXLINE( 224)							dif1 = -(theta);
            						}
HXDLIN( 224)						if ((dif1 < 0)) {
HXLINE( 224)							dif = dif1;
            						}
            						else {
HXLINE( 224)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE( 224)						Float f;
HXDLIN( 224)						bool f1;
HXDLIN( 224)						if ((beta >= 0)) {
HXLINE( 224)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 224)							f1 = false;
            						}
HXDLIN( 224)						if (f1) {
HXLINE( 224)							f = beta;
            						}
            						else {
HXLINE( 224)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 224)							if ((a >= 0)) {
HXLINE( 224)								f = a;
            							}
            							else {
HXLINE( 224)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 224)						Float this1 = f;
HXDLIN( 224)						Float za = this1;
HXDLIN( 224)						Float f2;
HXDLIN( 224)						bool f3;
HXDLIN( 224)						if ((gamma >= 0)) {
HXLINE( 224)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 224)							f3 = false;
            						}
HXDLIN( 224)						if (f3) {
HXLINE( 224)							f2 = gamma;
            						}
            						else {
HXLINE( 224)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 224)							if ((a >= 0)) {
HXLINE( 224)								f2 = a;
            							}
            							else {
HXLINE( 224)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 224)						Float this2 = f2;
HXDLIN( 224)						Float zb = this2;
HXDLIN( 224)						Float fa = za;
HXDLIN( 224)						Float fb = zb;
HXDLIN( 224)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 224)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 224)						bool clockwise = (fa < fb);
HXDLIN( 224)						Float dif1;
HXDLIN( 224)						if (clockwise) {
HXLINE( 224)							dif1 = theta;
            						}
            						else {
HXLINE( 224)							dif1 = -(theta);
            						}
HXDLIN( 224)						if (smallest) {
HXLINE( 224)							dif = dif1;
            						}
            						else {
HXLINE( 224)							if (clockwise) {
HXLINE( 224)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 224)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE( 224)						Float f;
HXDLIN( 224)						bool f1;
HXDLIN( 224)						if ((beta >= 0)) {
HXLINE( 224)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 224)							f1 = false;
            						}
HXDLIN( 224)						if (f1) {
HXLINE( 224)							f = beta;
            						}
            						else {
HXLINE( 224)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 224)							if ((a >= 0)) {
HXLINE( 224)								f = a;
            							}
            							else {
HXLINE( 224)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 224)						Float this1 = f;
HXDLIN( 224)						Float za = this1;
HXDLIN( 224)						Float f2;
HXDLIN( 224)						bool f3;
HXDLIN( 224)						if ((gamma >= 0)) {
HXLINE( 224)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 224)							f3 = false;
            						}
HXDLIN( 224)						if (f3) {
HXLINE( 224)							f2 = gamma;
            						}
            						else {
HXLINE( 224)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 224)							if ((a >= 0)) {
HXLINE( 224)								f2 = a;
            							}
            							else {
HXLINE( 224)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 224)						Float this2 = f2;
HXDLIN( 224)						Float zb = this2;
HXDLIN( 224)						Float fa = za;
HXDLIN( 224)						Float fb = zb;
HXDLIN( 224)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 224)						bool largest = (theta > ::Math_obj::PI);
HXDLIN( 224)						bool clockwise = (fa < fb);
HXDLIN( 224)						Float dif1;
HXDLIN( 224)						if (clockwise) {
HXLINE( 224)							dif1 = theta;
            						}
            						else {
HXLINE( 224)							dif1 = -(theta);
            						}
HXDLIN( 224)						if (largest) {
HXLINE( 224)							dif = dif1;
            						}
            						else {
HXLINE( 224)							if (clockwise) {
HXLINE( 224)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 224)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN( 224)				bool positive = (dif >= 0);
HXDLIN( 224)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 224)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 224)				Float angle = beta;
HXDLIN( 224)				Float cx;
HXDLIN( 224)				Float cy;
HXDLIN( 224)				Float bx = ( (Float)(0) );
HXDLIN( 224)				Float by = ( (Float)(0) );
HXDLIN( 224)				int p2 = temp->length;
HXDLIN( 224)				{
HXLINE( 224)					int _g = 0;
HXDLIN( 224)					int _g1 = (totalSteps + 1);
HXDLIN( 224)					while((_g < _g1)){
HXLINE( 224)						_g = (_g + 1);
HXDLIN( 224)						int i = (_g - 1);
HXDLIN( 224)						cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 224)						cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 224)						p2 = (p2 + 1);
HXDLIN( 224)						temp[(p2 - 1)] = cx;
HXDLIN( 224)						p2 = (p2 + 1);
HXDLIN( 224)						temp[(p2 - 1)] = cy;
HXDLIN( 224)						if ((i != 0)) {
HXLINE( 224)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 224)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 224)							if (::hx::IsNotNull( m )) {
HXLINE( 224)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN( 224)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 224)						angle = (angle + step1);
HXDLIN( 224)						bx = cx;
HXDLIN( 224)						by = cy;
            					}
            				}
HXDLIN( 224)				int len = totalSteps;
HXDLIN( 224)				{
HXLINE( 224)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN( 224)					int color = 0;
HXDLIN( 224)					if ((color == -1)) {
HXLINE( 224)						color = _this1->currentColor;
            					}
HXDLIN( 224)					_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            				}
HXDLIN( 224)				int pA = _this->pointsAnti->length;
HXDLIN( 224)				int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 224)				{
HXLINE( 224)					int _g2 = 0;
HXDLIN( 224)					int _g3 = (len1 + 2);
HXDLIN( 224)					while((_g2 < _g3)){
HXLINE( 224)						_g2 = (_g2 + 1);
HXDLIN( 224)						int i = (_g2 - 1);
HXDLIN( 224)						pA = (pA + 1);
HXDLIN( 224)						_this->pointsAnti[(pA - 1)] = temp->__get(i);
            					}
            				}
HXDLIN( 224)				int pC = _this->pointsClock->length;
HXDLIN( 224)				{
HXLINE( 224)					int _g4 = 1;
HXDLIN( 224)					int _g5 = ::Std_obj::_hx_int(((( (Float)(len1) ) / ( (Float)(2) )) + 1));
HXDLIN( 224)					while((_g4 < _g5)){
HXLINE( 224)						_g4 = (_g4 + 1);
HXDLIN( 224)						int i = (_g4 - 1);
HXDLIN( 224)						pC = (pC + 1);
HXDLIN( 224)						_this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXDLIN( 224)						pC = (pC + 1);
HXDLIN( 224)						_this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            					}
            				}
            			}
            		}
HXLINE( 225)		this->x = x_;
HXLINE( 226)		this->y = y_;
HXLINE( 227)		int l = this->points->length;
HXLINE( 228)		this->points[l] = ::Array_obj< Float >::__new();
HXLINE( 229)		this->points->__get(l).StaticCast< ::Array< Float > >()[0] = x_;
HXLINE( 230)		this->points->__get(l).StaticCast< ::Array< Float > >()[1] = y_;
HXLINE( 233)		this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXLINE( 234)		this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
HXLINE( 236)		this->dim[this->dim->length] =  ::Dynamic(::hx::Anon_obj::Create(4)
            			->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            			->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
HXLINE( 237)		{
HXLINE( 237)			 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 237)			if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 237)				d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            			}
HXDLIN( 237)			if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 237)				d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            			}
HXDLIN( 237)			if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 237)				d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            			}
HXDLIN( 237)			if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 237)				d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            			}
            		}
HXLINE( 238)		this->contour->reset();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,moveTo,(void))

void Sketch_obj::lastClock(){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_242_lastClock)
HXDLIN( 242)		if ((this->contour->pointsClock->length != 0)) {
HXLINE( 244)			this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXLINE( 245)			this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,lastClock,(void))

::Array< ::Dynamic> Sketch_obj::getEdges(){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_251_getEdges)
HXLINE( 252)		::Array< ::Dynamic> edges = ::Array_obj< ::Dynamic>::__new();
HXLINE( 253)		int no = this->pointsClock->length;
HXLINE( 254)		if ((no > this->pointsAnti->length)) {
HXLINE( 254)			no = this->pointsAnti->length;
            		}
HXLINE( 255)		::Array< Float > pClock;
HXLINE( 256)		::Array< Float > pAnti;
HXLINE( 257)		::Array< Float > shape;
HXLINE( 258)		{
HXLINE( 258)			int _g = 0;
HXDLIN( 258)			int _g1 = no;
HXDLIN( 258)			while((_g < _g1)){
HXLINE( 258)				_g = (_g + 1);
HXDLIN( 258)				int s = (_g - 1);
HXLINE( 259)				pClock = this->pointsClock->__get(s).StaticCast< ::Array< Float > >();
HXLINE( 260)				pAnti = this->pointsAnti->__get(s).StaticCast< ::Array< Float > >();
HXLINE( 261)				int lc = pClock->length;
HXLINE( 262)				int la = pAnti->length;
HXLINE( 263)				edges[s] = ::Array_obj< Float >::__new();
HXLINE( 264)				shape = edges->__get(s).StaticCast< ::Array< Float > >();
HXLINE( 265)				{
HXLINE( 265)					int _g1 = 0;
HXDLIN( 265)					int _g2 = lc;
HXDLIN( 265)					while((_g1 < _g2)){
HXLINE( 265)						_g1 = (_g1 + 1);
HXDLIN( 265)						int i = (_g1 - 1);
HXDLIN( 265)						shape[i] = pClock->__get(i);
            					}
            				}
HXLINE( 266)				int j = shape->length;
HXLINE( 267)				int l5 = ::Std_obj::_hx_int((( (Float)(la) ) / ( (Float)(2) )));
HXLINE( 268)				{
HXLINE( 268)					int _g3 = 0;
HXDLIN( 268)					int _g4 = l5;
HXDLIN( 268)					while((_g3 < _g4)){
HXLINE( 268)						_g3 = (_g3 + 1);
HXDLIN( 268)						int i = (_g3 - 1);
HXLINE( 269)						shape[(j + (i * 2))] = pAnti->__get(((la - (i * 2)) - 1));
HXLINE( 270)						shape[((j + (i * 2)) + 1)] = pAnti->__get((la - (i * 2)));
            					}
            				}
HXLINE( 272)				j = shape->length;
HXLINE( 273)				j = (j + 1);
HXDLIN( 273)				shape[(j - 1)] = pClock->__get(0);
HXLINE( 274)				shape[j] = pClock->__get(1);
            			}
            		}
HXLINE( 276)		return edges;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,getEdges,return )

void Sketch_obj::lineTo(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_279_lineTo)
HXLINE( 280)		bool repeat;
HXDLIN( 280)		if ((this->x == x_)) {
HXLINE( 280)			repeat = (this->y == y_);
            		}
            		else {
HXLINE( 280)			repeat = false;
            		}
HXLINE( 281)		if (!(repeat)) {
HXLINE( 282)			if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 282)				this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            			}
HXLINE( 283)			if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 283)				this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            			}
HXLINE( 284)			this->line(x_,y_);
HXLINE( 285)			int l = this->points->length;
HXLINE( 286)			::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXLINE( 287)			int l2 = p->length;
HXLINE( 288)			p[l2] = x_;
HXLINE( 289)			p[(l2 + 1)] = y_;
HXLINE( 290)			{
HXLINE( 290)				 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 290)				if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 290)					d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            				}
HXDLIN( 290)				if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 290)					d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            				}
HXDLIN( 290)				if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 290)					d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            				}
HXDLIN( 290)				if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 290)					d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            				}
            			}
HXLINE( 291)			this->x = x_;
HXLINE( 292)			this->y = y_;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,lineTo,(void))

void Sketch_obj::quadTo(Float x1,Float y1,Float x2,Float y2){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_296_quadTo)
HXLINE( 297)		this->tempArr = ::Array_obj< Float >::__new(0);
HXLINE( 298)		{
HXLINE( 298)			::Array< Float > p = this->tempArr;
HXDLIN( 298)			Float ax = this->x;
HXDLIN( 298)			Float ay = this->y;
HXDLIN( 298)			Float x = (ax - x1);
HXDLIN( 298)			Float y = (ay - y1);
HXDLIN( 298)			Float x3 = (x1 - x2);
HXDLIN( 298)			Float y3 = (y1 - y2);
HXDLIN( 298)			Float approxDistance = (::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x3 * x3) + (y3 * y3))));
HXDLIN( 298)			if ((approxDistance == 0)) {
HXLINE( 298)				approxDistance = ((Float)0.000001);
            			}
HXDLIN( 298)			Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::trilateral3::math::_Algebra::Algebra_Fields__obj::quadStep);
HXDLIN( 298)			int l = p->length;
HXDLIN( 298)			l = (l + 1);
HXDLIN( 298)			p[(l - 1)] = ax;
HXDLIN( 298)			l = (l + 1);
HXDLIN( 298)			p[(l - 1)] = ay;
HXDLIN( 298)			Float t = step;
HXDLIN( 298)			while((t < ((Float)1.))){
HXLINE( 298)				l = (l + 1);
HXDLIN( 298)				Float u = (( (Float)(1) ) - t);
HXDLIN( 298)				p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * x1)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
HXDLIN( 298)				l = (l + 1);
HXDLIN( 298)				Float u1 = (( (Float)(1) ) - t);
HXDLIN( 298)				p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * y1)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
HXDLIN( 298)				t = (t + step);
            			}
HXDLIN( 298)			l = (l + 1);
HXDLIN( 298)			p[(l - 1)] = x2;
HXDLIN( 298)			l = (l + 1);
HXDLIN( 298)			p[(l - 1)] = y2;
            		}
HXLINE( 299)		{
HXLINE( 299)			::Array< Float > arr = this->tempArr;
HXDLIN( 299)			 ::Dynamic withMove = false;
HXDLIN( 299)			if (::hx::IsNull( withMove )) {
HXLINE( 299)				withMove = true;
            			}
HXDLIN( 299)			int l1 = arr->length;
HXDLIN( 299)			int i = 2;
HXDLIN( 299)			if (( (bool)(withMove) )) {
HXLINE( 299)				this->moveTo(arr->__get(0),arr->__get(1));
            			}
            			else {
HXLINE( 299)				Float x_ = arr->__get(0);
HXDLIN( 299)				Float y_ = arr->__get(1);
HXDLIN( 299)				bool repeat;
HXDLIN( 299)				if ((this->x == x_)) {
HXLINE( 299)					repeat = (this->y == y_);
            				}
            				else {
HXLINE( 299)					repeat = false;
            				}
HXDLIN( 299)				if (!(repeat)) {
HXLINE( 299)					if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 299)						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 299)					if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 299)						this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 299)					this->line(x_,y_);
HXDLIN( 299)					int l = this->points->length;
HXDLIN( 299)					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 299)					int l2 = p->length;
HXDLIN( 299)					p[l2] = x_;
HXDLIN( 299)					p[(l2 + 1)] = y_;
HXDLIN( 299)					{
HXLINE( 299)						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 299)						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 299)							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 299)						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 299)							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 299)						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 299)							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            						}
HXDLIN( 299)						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 299)							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            						}
            					}
HXDLIN( 299)					this->x = x_;
HXDLIN( 299)					this->y = y_;
            				}
            			}
HXDLIN( 299)			while((i < l1)){
HXLINE( 299)				{
HXLINE( 299)					Float x_ = arr->__get(i);
HXDLIN( 299)					Float y_ = arr->__get((i + 1));
HXDLIN( 299)					bool repeat;
HXDLIN( 299)					if ((this->x == x_)) {
HXLINE( 299)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 299)						repeat = false;
            					}
HXDLIN( 299)					if (!(repeat)) {
HXLINE( 299)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 299)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 299)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 299)							this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 299)						this->line(x_,y_);
HXDLIN( 299)						int l = this->points->length;
HXDLIN( 299)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 299)						int l2 = p->length;
HXDLIN( 299)						p[l2] = x_;
HXDLIN( 299)						p[(l2 + 1)] = y_;
HXDLIN( 299)						{
HXLINE( 299)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 299)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 299)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 299)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 299)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 299)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 299)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 299)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 299)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 299)						this->x = x_;
HXDLIN( 299)						this->y = y_;
            					}
            				}
HXDLIN( 299)				i = (i + 2);
            			}
            		}
HXLINE( 300)		this->x = x2;
HXLINE( 301)		this->y = y2;
            	}


HX_DEFINE_DYNAMIC_FUNC4(Sketch_obj,quadTo,(void))

void Sketch_obj::quadThru(Float x1,Float y1,Float x2,Float y2){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_305_quadThru)
HXLINE( 306)		Float newx = ((( (Float)(2) ) * x1) - (((Float)0.5) * (this->x + x2)));
HXLINE( 307)		Float newy = ((( (Float)(2) ) * y1) - (((Float)0.5) * (this->y + y2)));
HXLINE( 308)		{
HXLINE( 308)			this->tempArr = ::Array_obj< Float >::__new(0);
HXDLIN( 308)			{
HXLINE( 308)				::Array< Float > p = this->tempArr;
HXDLIN( 308)				Float ax = this->x;
HXDLIN( 308)				Float ay = this->y;
HXDLIN( 308)				Float x = (ax - newx);
HXDLIN( 308)				Float y = (ay - newy);
HXDLIN( 308)				Float x3 = (newx - x2);
HXDLIN( 308)				Float y3 = (newy - y2);
HXDLIN( 308)				Float approxDistance = (::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x3 * x3) + (y3 * y3))));
HXDLIN( 308)				if ((approxDistance == 0)) {
HXLINE( 308)					approxDistance = ((Float)0.000001);
            				}
HXDLIN( 308)				Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::trilateral3::math::_Algebra::Algebra_Fields__obj::quadStep);
HXDLIN( 308)				int l = p->length;
HXDLIN( 308)				l = (l + 1);
HXDLIN( 308)				p[(l - 1)] = ax;
HXDLIN( 308)				l = (l + 1);
HXDLIN( 308)				p[(l - 1)] = ay;
HXDLIN( 308)				Float t = step;
HXDLIN( 308)				while((t < ((Float)1.))){
HXLINE( 308)					l = (l + 1);
HXDLIN( 308)					Float u = (( (Float)(1) ) - t);
HXDLIN( 308)					p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * newx)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
HXDLIN( 308)					l = (l + 1);
HXDLIN( 308)					Float u1 = (( (Float)(1) ) - t);
HXDLIN( 308)					p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * newy)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
HXDLIN( 308)					t = (t + step);
            				}
HXDLIN( 308)				l = (l + 1);
HXDLIN( 308)				p[(l - 1)] = x2;
HXDLIN( 308)				l = (l + 1);
HXDLIN( 308)				p[(l - 1)] = y2;
            			}
HXDLIN( 308)			{
HXLINE( 308)				::Array< Float > arr = this->tempArr;
HXDLIN( 308)				 ::Dynamic withMove = false;
HXDLIN( 308)				if (::hx::IsNull( withMove )) {
HXLINE( 308)					withMove = true;
            				}
HXDLIN( 308)				int l1 = arr->length;
HXDLIN( 308)				int i = 2;
HXDLIN( 308)				if (( (bool)(withMove) )) {
HXLINE( 308)					this->moveTo(arr->__get(0),arr->__get(1));
            				}
            				else {
HXLINE( 308)					Float x_ = arr->__get(0);
HXDLIN( 308)					Float y_ = arr->__get(1);
HXDLIN( 308)					bool repeat;
HXDLIN( 308)					if ((this->x == x_)) {
HXLINE( 308)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 308)						repeat = false;
            					}
HXDLIN( 308)					if (!(repeat)) {
HXLINE( 308)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 308)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 308)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 308)							this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 308)						this->line(x_,y_);
HXDLIN( 308)						int l = this->points->length;
HXDLIN( 308)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 308)						int l2 = p->length;
HXDLIN( 308)						p[l2] = x_;
HXDLIN( 308)						p[(l2 + 1)] = y_;
HXDLIN( 308)						{
HXLINE( 308)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 308)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 308)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 308)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 308)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 308)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 308)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 308)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 308)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 308)						this->x = x_;
HXDLIN( 308)						this->y = y_;
            					}
            				}
HXDLIN( 308)				while((i < l1)){
HXLINE( 308)					{
HXLINE( 308)						Float x_ = arr->__get(i);
HXDLIN( 308)						Float y_ = arr->__get((i + 1));
HXDLIN( 308)						bool repeat;
HXDLIN( 308)						if ((this->x == x_)) {
HXLINE( 308)							repeat = (this->y == y_);
            						}
            						else {
HXLINE( 308)							repeat = false;
            						}
HXDLIN( 308)						if (!(repeat)) {
HXLINE( 308)							if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 308)								this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            							}
HXDLIN( 308)							if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 308)								this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            							}
HXDLIN( 308)							this->line(x_,y_);
HXDLIN( 308)							int l = this->points->length;
HXDLIN( 308)							::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 308)							int l2 = p->length;
HXDLIN( 308)							p[l2] = x_;
HXDLIN( 308)							p[(l2 + 1)] = y_;
HXDLIN( 308)							{
HXLINE( 308)								 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 308)								if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 308)									d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            								}
HXDLIN( 308)								if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 308)									d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            								}
HXDLIN( 308)								if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 308)									d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            								}
HXDLIN( 308)								if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 308)									d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            								}
            							}
HXDLIN( 308)							this->x = x_;
HXDLIN( 308)							this->y = y_;
            						}
            					}
HXDLIN( 308)					i = (i + 2);
            				}
            			}
HXDLIN( 308)			this->x = x2;
HXDLIN( 308)			this->y = y2;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Sketch_obj,quadThru,(void))

void Sketch_obj::curveTo(Float x1,Float y1,Float x2,Float y2,Float x3,Float y3){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_311_curveTo)
HXLINE( 312)		this->tempArr = ::Array_obj< Float >::__new(0);
HXLINE( 313)		{
HXLINE( 313)			::Array< Float > p = this->tempArr;
HXDLIN( 313)			Float ax = this->x;
HXDLIN( 313)			Float ay = this->y;
HXDLIN( 313)			Float x = (ax - x1);
HXDLIN( 313)			Float y = (ay - y1);
HXDLIN( 313)			Float x4 = (x1 - x2);
HXDLIN( 313)			Float y4 = (y1 - y2);
HXDLIN( 313)			Float x5 = (x2 - x3);
HXDLIN( 313)			Float y5 = (y2 - y3);
HXDLIN( 313)			Float approxDistance = ((::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x4 * x4) + (y4 * y4)))) + ::Math_obj::sqrt(((x5 * x5) + (y5 * y5))));
HXDLIN( 313)			if ((approxDistance == 0)) {
HXLINE( 313)				approxDistance = ((Float)0.000001);
            			}
HXDLIN( 313)			Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),((Float)0.03));
HXDLIN( 313)			int l = p->length;
HXDLIN( 313)			l = (l + 1);
HXDLIN( 313)			p[(l - 1)] = ax;
HXDLIN( 313)			l = (l + 1);
HXDLIN( 313)			p[(l - 1)] = ay;
HXDLIN( 313)			Float t = step;
HXDLIN( 313)			while((t < ((Float)1.))){
HXLINE( 313)				l = (l + 1);
HXDLIN( 313)				Float u = (( (Float)(1) ) - t);
HXDLIN( 313)				p[(l - 1)] = ((((::Math_obj::pow(u,( (Float)(3) )) * ax) + (((( (Float)(3) ) * ::Math_obj::pow(u,( (Float)(2) ))) * t) * x1)) + (((( (Float)(3) ) * u) * ::Math_obj::pow(t,( (Float)(2) ))) * x2)) + (::Math_obj::pow(t,( (Float)(3) )) * x3));
HXDLIN( 313)				l = (l + 1);
HXDLIN( 313)				Float u1 = (( (Float)(1) ) - t);
HXDLIN( 313)				p[(l - 1)] = ((((::Math_obj::pow(u1,( (Float)(3) )) * ay) + (((( (Float)(3) ) * ::Math_obj::pow(u1,( (Float)(2) ))) * t) * y1)) + (((( (Float)(3) ) * u1) * ::Math_obj::pow(t,( (Float)(2) ))) * y2)) + (::Math_obj::pow(t,( (Float)(3) )) * y3));
HXDLIN( 313)				t = (t + step);
            			}
HXDLIN( 313)			l = (l + 1);
HXDLIN( 313)			p[(l - 1)] = x3;
HXDLIN( 313)			l = (l + 1);
HXDLIN( 313)			p[(l - 1)] = y3;
            		}
HXLINE( 314)		{
HXLINE( 314)			::Array< Float > arr = this->tempArr;
HXDLIN( 314)			 ::Dynamic withMove = false;
HXDLIN( 314)			if (::hx::IsNull( withMove )) {
HXLINE( 314)				withMove = true;
            			}
HXDLIN( 314)			int l1 = arr->length;
HXDLIN( 314)			int i = 2;
HXDLIN( 314)			if (( (bool)(withMove) )) {
HXLINE( 314)				this->moveTo(arr->__get(0),arr->__get(1));
            			}
            			else {
HXLINE( 314)				Float x_ = arr->__get(0);
HXDLIN( 314)				Float y_ = arr->__get(1);
HXDLIN( 314)				bool repeat;
HXDLIN( 314)				if ((this->x == x_)) {
HXLINE( 314)					repeat = (this->y == y_);
            				}
            				else {
HXLINE( 314)					repeat = false;
            				}
HXDLIN( 314)				if (!(repeat)) {
HXLINE( 314)					if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 314)						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 314)					if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 314)						this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 314)					this->line(x_,y_);
HXDLIN( 314)					int l = this->points->length;
HXDLIN( 314)					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 314)					int l2 = p->length;
HXDLIN( 314)					p[l2] = x_;
HXDLIN( 314)					p[(l2 + 1)] = y_;
HXDLIN( 314)					{
HXLINE( 314)						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 314)						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 314)							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 314)						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 314)							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 314)						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 314)							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            						}
HXDLIN( 314)						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 314)							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            						}
            					}
HXDLIN( 314)					this->x = x_;
HXDLIN( 314)					this->y = y_;
            				}
            			}
HXDLIN( 314)			while((i < l1)){
HXLINE( 314)				{
HXLINE( 314)					Float x_ = arr->__get(i);
HXDLIN( 314)					Float y_ = arr->__get((i + 1));
HXDLIN( 314)					bool repeat;
HXDLIN( 314)					if ((this->x == x_)) {
HXLINE( 314)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 314)						repeat = false;
            					}
HXDLIN( 314)					if (!(repeat)) {
HXLINE( 314)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 314)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 314)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 314)							this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 314)						this->line(x_,y_);
HXDLIN( 314)						int l = this->points->length;
HXDLIN( 314)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 314)						int l2 = p->length;
HXDLIN( 314)						p[l2] = x_;
HXDLIN( 314)						p[(l2 + 1)] = y_;
HXDLIN( 314)						{
HXLINE( 314)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 314)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 314)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 314)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 314)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 314)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 314)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 314)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 314)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 314)						this->x = x_;
HXDLIN( 314)						this->y = y_;
            					}
            				}
HXDLIN( 314)				i = (i + 2);
            			}
            		}
HXLINE( 315)		this->x = x3;
HXLINE( 316)		this->y = y3;
            	}


HX_DEFINE_DYNAMIC_FUNC6(Sketch_obj,curveTo,(void))

void Sketch_obj::plotCoord(::Array< Float > arr, ::Dynamic __o_withMove){
            		 ::Dynamic withMove = __o_withMove;
            		if (::hx::IsNull(__o_withMove)) withMove = true;
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_319_plotCoord)
HXLINE( 320)		int l = arr->length;
HXLINE( 321)		int i = 2;
HXLINE( 322)		if (( (bool)(withMove) )) {
HXLINE( 323)			this->moveTo(arr->__get(0),arr->__get(1));
            		}
            		else {
HXLINE( 325)			Float x_ = arr->__get(0);
HXDLIN( 325)			Float y_ = arr->__get(1);
HXDLIN( 325)			bool repeat;
HXDLIN( 325)			if ((this->x == x_)) {
HXLINE( 325)				repeat = (this->y == y_);
            			}
            			else {
HXLINE( 325)				repeat = false;
            			}
HXDLIN( 325)			if (!(repeat)) {
HXLINE( 325)				if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 325)					this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            				}
HXDLIN( 325)				if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 325)					this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            				}
HXDLIN( 325)				this->line(x_,y_);
HXDLIN( 325)				int l = this->points->length;
HXDLIN( 325)				::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 325)				int l2 = p->length;
HXDLIN( 325)				p[l2] = x_;
HXDLIN( 325)				p[(l2 + 1)] = y_;
HXDLIN( 325)				{
HXLINE( 325)					 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 325)					if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 325)						d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            					}
HXDLIN( 325)					if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 325)						d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            					}
HXDLIN( 325)					if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 325)						d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            					}
HXDLIN( 325)					if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 325)						d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            					}
            				}
HXDLIN( 325)				this->x = x_;
HXDLIN( 325)				this->y = y_;
            			}
            		}
HXLINE( 327)		while((i < l)){
HXLINE( 328)			{
HXLINE( 328)				Float x_ = arr->__get(i);
HXDLIN( 328)				Float y_ = arr->__get((i + 1));
HXDLIN( 328)				bool repeat;
HXDLIN( 328)				if ((this->x == x_)) {
HXLINE( 328)					repeat = (this->y == y_);
            				}
            				else {
HXLINE( 328)					repeat = false;
            				}
HXDLIN( 328)				if (!(repeat)) {
HXLINE( 328)					if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 328)						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 328)					if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 328)						this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 328)					this->line(x_,y_);
HXDLIN( 328)					int l = this->points->length;
HXDLIN( 328)					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 328)					int l2 = p->length;
HXDLIN( 328)					p[l2] = x_;
HXDLIN( 328)					p[(l2 + 1)] = y_;
HXDLIN( 328)					{
HXLINE( 328)						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 328)						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 328)							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 328)						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 328)							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 328)						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 328)							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            						}
HXDLIN( 328)						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 328)							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            						}
            					}
HXDLIN( 328)					this->x = x_;
HXDLIN( 328)					this->y = y_;
            				}
            			}
HXLINE( 329)			i = (i + 2);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,plotCoord,(void))

void Sketch_obj::aiString(::String str,Float x,Float y,::hx::Null< Float >  __o_flipY){
            		Float flipY = __o_flipY.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_6351d8d914bc61da_334_aiString)
HXLINE( 335)		 ::dsHelper::splitter::StringCodeIterator sl =  ::dsHelper::splitter::StringCodeIterator_obj::__alloc( HX_CTX ,str,null());
HXDLIN( 335)		sl->c = sl->str.cca(sl->pos++);
HXDLIN( 335)		::Array< ::Dynamic> arr = ::Array_obj< ::Dynamic>::__new();
HXDLIN( 335)		::Array< ::String > arrTemp = ::Array_obj< ::String >::__new();
HXDLIN( 335)		int no = 0;
HXDLIN( 335)		int count = 0;
HXDLIN( 335)		while((sl->pos < sl->length)){
HXLINE( 335)			switch((int)(sl->c)){
            				case (int)10: case (int)13: {
HXLINE( 335)					sl->last2 = sl->last;
HXDLIN( 335)					sl->last = sl->b->toString();
HXDLIN( 335)					arrTemp[count] = sl->last;
HXDLIN( 335)					no = (no + 1);
HXDLIN( 335)					arr[(no - 1)] = arrTemp->copy();
HXDLIN( 335)					count = 0;
HXDLIN( 335)					sl->b =  ::StringBuf_obj::__alloc( HX_CTX );
            				}
            				break;
            				case (int)32: {
HXLINE( 335)					if ((count == 0)) {
HXLINE( 335)						arrTemp->resize(0);
HXDLIN( 335)						sl->last2 = sl->last;
HXDLIN( 335)						sl->last = sl->b->toString();
HXDLIN( 335)						arrTemp[0] = sl->last;
            					}
            					else {
HXLINE( 335)						sl->last2 = sl->last;
HXDLIN( 335)						sl->last = sl->b->toString();
HXDLIN( 335)						arrTemp[count] = sl->last;
            					}
HXDLIN( 335)					count = (count + 1);
HXDLIN( 335)					sl->b =  ::StringBuf_obj::__alloc( HX_CTX );
            				}
            				break;
            				default:{
HXLINE( 335)					 ::StringBuf _this = sl->b;
HXDLIN( 335)					int c = sl->c;
HXDLIN( 335)					if ((c >= 127)) {
HXLINE( 335)						::String x = ::String::fromCharCode(c);
HXDLIN( 335)						if (::hx::IsNotNull( _this->charBuf )) {
HXLINE( 335)							_this->flush();
            						}
HXDLIN( 335)						if (::hx::IsNull( _this->b )) {
HXLINE( 335)							_this->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x));
            						}
            						else {
HXLINE( 335)							::Array< ::String > _this1 = _this->b;
HXDLIN( 335)							_this1->push(::Std_obj::string(x));
            						}
            					}
            					else {
HXLINE( 335)						if (::hx::IsNull( _this->charBuf )) {
HXLINE( 335)							_this->charBuf = ::Array_obj< char >::__new();
            						}
HXDLIN( 335)						_this->charBuf->push(c);
            					}
            				}
            			}
HXDLIN( 335)			sl->c = sl->str.cca(sl->pos++);
            		}
HXDLIN( 335)		::Array< ::Dynamic> arr1 = arr;
HXLINE( 336)		::Array< ::String > arr2 = ( (::Array< ::String >)(arr1->shift()) );
HXLINE( 337)		Float c = ::Std_obj::parseFloat(arr2->__get(0));
HXDLIN( 337)		Float y1 = ::Std_obj::parseFloat(arr2->__get(1));
HXDLIN( 337)		Float m = ::Std_obj::parseFloat(arr2->__get(2));
HXDLIN( 337)		Float k = ::Std_obj::parseFloat(arr2->__get(3));
HXDLIN( 337)		int this1 = ((((::Math_obj::round(((Float)255.)) << 24) | (::Math_obj::round((((( (Float)(1) ) - (c / ( (Float)(100) ))) * (( (Float)(1) ) - (k / ( (Float)(100) )))) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((((( (Float)(1) ) - (m / ( (Float)(100) ))) * (( (Float)(1) ) - (k / ( (Float)(100) )))) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((((( (Float)(1) ) - (y1 / ( (Float)(100) ))) * (( (Float)(1) ) - (k / ( (Float)(100) )))) * ( (Float)(255) ))));
HXDLIN( 337)		int colorInt = this1;
HXLINE( 338)		this->pen->currentColor = colorInt;
HXLINE( 339)		int len = arr1->length;
HXLINE( 340)		if ((flipY == 0)) {
HXLINE( 341)			int _g = 0;
HXDLIN( 341)			int _g1 = len;
HXDLIN( 341)			while((_g < _g1)){
HXLINE( 341)				_g = (_g + 1);
HXDLIN( 341)				int i = (_g - 1);
HXLINE( 342)				int len2 = arr1->__get(i).StaticCast< ::Array< ::String > >()->length;
HXLINE( 343)				::Array< ::String > arr3 = arr1->__get(i).StaticCast< ::Array< ::String > >();
HXLINE( 344)				::String str = arr3->__get((len2 - 1));
HXLINE( 345)				::String _hx_switch_0 = str;
            				if (  (_hx_switch_0==HX_("C",43,00,00,00)) ){
HXLINE( 351)					Float x1 = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 351)					Float y1 = (::Std_obj::parseFloat(arr3->__get(1)) + y);
HXDLIN( 351)					Float x2 = (::Std_obj::parseFloat(arr3->__get(1)) + x);
HXDLIN( 351)					Float y2 = (::Std_obj::parseFloat(arr3->__get(2)) + y);
HXDLIN( 351)					this->tempArr = ::Array_obj< Float >::__new(0);
HXDLIN( 351)					{
HXLINE( 351)						::Array< Float > p = this->tempArr;
HXDLIN( 351)						Float ax = this->x;
HXDLIN( 351)						Float ay = this->y;
HXDLIN( 351)						Float x3 = (ax - x1);
HXDLIN( 351)						Float y3 = (ay - y1);
HXDLIN( 351)						Float x4 = (x1 - x2);
HXDLIN( 351)						Float y4 = (y1 - y2);
HXDLIN( 351)						Float approxDistance = (::Math_obj::sqrt(((x3 * x3) + (y3 * y3))) + ::Math_obj::sqrt(((x4 * x4) + (y4 * y4))));
HXDLIN( 351)						if ((approxDistance == 0)) {
HXLINE( 351)							approxDistance = ((Float)0.000001);
            						}
HXDLIN( 351)						Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::trilateral3::math::_Algebra::Algebra_Fields__obj::quadStep);
HXDLIN( 351)						int l = p->length;
HXDLIN( 351)						l = (l + 1);
HXDLIN( 351)						p[(l - 1)] = ax;
HXDLIN( 351)						l = (l + 1);
HXDLIN( 351)						p[(l - 1)] = ay;
HXDLIN( 351)						Float t = step;
HXDLIN( 351)						while((t < ((Float)1.))){
HXLINE( 351)							l = (l + 1);
HXDLIN( 351)							Float u = (( (Float)(1) ) - t);
HXDLIN( 351)							p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * x1)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
HXDLIN( 351)							l = (l + 1);
HXDLIN( 351)							Float u1 = (( (Float)(1) ) - t);
HXDLIN( 351)							p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * y1)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
HXDLIN( 351)							t = (t + step);
            						}
HXDLIN( 351)						l = (l + 1);
HXDLIN( 351)						p[(l - 1)] = x2;
HXDLIN( 351)						l = (l + 1);
HXDLIN( 351)						p[(l - 1)] = y2;
            					}
HXDLIN( 351)					{
HXLINE( 351)						::Array< Float > arr = this->tempArr;
HXDLIN( 351)						 ::Dynamic withMove = false;
HXDLIN( 351)						if (::hx::IsNull( withMove )) {
HXLINE( 351)							withMove = true;
            						}
HXDLIN( 351)						int l1 = arr->length;
HXDLIN( 351)						int i = 2;
HXDLIN( 351)						if (( (bool)(withMove) )) {
HXLINE( 351)							this->moveTo(arr->__get(0),arr->__get(1));
            						}
            						else {
HXLINE( 351)							Float x_ = arr->__get(0);
HXDLIN( 351)							Float y_ = arr->__get(1);
HXDLIN( 351)							bool repeat;
HXDLIN( 351)							if ((this->x == x_)) {
HXLINE( 351)								repeat = (this->y == y_);
            							}
            							else {
HXLINE( 351)								repeat = false;
            							}
HXDLIN( 351)							if (!(repeat)) {
HXLINE( 351)								if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 351)									this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            								}
HXDLIN( 351)								if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 351)									this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            								}
HXDLIN( 351)								this->line(x_,y_);
HXDLIN( 351)								int l = this->points->length;
HXDLIN( 351)								::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 351)								int l2 = p->length;
HXDLIN( 351)								p[l2] = x_;
HXDLIN( 351)								p[(l2 + 1)] = y_;
HXDLIN( 351)								{
HXLINE( 351)									 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 351)									if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 351)										d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            									}
HXDLIN( 351)									if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 351)										d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            									}
HXDLIN( 351)									if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 351)										d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            									}
HXDLIN( 351)									if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 351)										d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            									}
            								}
HXDLIN( 351)								this->x = x_;
HXDLIN( 351)								this->y = y_;
            							}
            						}
HXDLIN( 351)						while((i < l1)){
HXLINE( 351)							{
HXLINE( 351)								Float x_ = arr->__get(i);
HXDLIN( 351)								Float y_ = arr->__get((i + 1));
HXDLIN( 351)								bool repeat;
HXDLIN( 351)								if ((this->x == x_)) {
HXLINE( 351)									repeat = (this->y == y_);
            								}
            								else {
HXLINE( 351)									repeat = false;
            								}
HXDLIN( 351)								if (!(repeat)) {
HXLINE( 351)									if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 351)										this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            									}
HXDLIN( 351)									if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 351)										this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            									}
HXDLIN( 351)									this->line(x_,y_);
HXDLIN( 351)									int l = this->points->length;
HXDLIN( 351)									::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 351)									int l2 = p->length;
HXDLIN( 351)									p[l2] = x_;
HXDLIN( 351)									p[(l2 + 1)] = y_;
HXDLIN( 351)									{
HXLINE( 351)										 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 351)										if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 351)											d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            										}
HXDLIN( 351)										if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 351)											d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            										}
HXDLIN( 351)										if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 351)											d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            										}
HXDLIN( 351)										if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 351)											d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            										}
            									}
HXDLIN( 351)									this->x = x_;
HXDLIN( 351)									this->y = y_;
            								}
            							}
HXDLIN( 351)							i = (i + 2);
            						}
            					}
HXDLIN( 351)					this->x = x2;
HXDLIN( 351)					this->y = y2;
HXDLIN( 351)					goto _hx_goto_64;
            				}
            				if (  (_hx_switch_0==HX_("L",4c,00,00,00)) ){
HXLINE( 349)					Float x_ = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 349)					Float y_ = (::Std_obj::parseFloat(arr3->__get(1)) + y);
HXDLIN( 349)					bool repeat;
HXDLIN( 349)					if ((this->x == x_)) {
HXLINE( 349)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 349)						repeat = false;
            					}
HXDLIN( 349)					if (!(repeat)) {
HXLINE( 349)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 349)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 349)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 349)							this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 349)						this->line(x_,y_);
HXDLIN( 349)						int l = this->points->length;
HXDLIN( 349)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 349)						int l2 = p->length;
HXDLIN( 349)						p[l2] = x_;
HXDLIN( 349)						p[(l2 + 1)] = y_;
HXDLIN( 349)						{
HXLINE( 349)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 349)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 349)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 349)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 349)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 349)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 349)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 349)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 349)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 349)						this->x = x_;
HXDLIN( 349)						this->y = y_;
            					}
HXDLIN( 349)					goto _hx_goto_64;
            				}
            				if (  (_hx_switch_0==HX_("m",6d,00,00,00)) ){
HXLINE( 347)					Float _hx_tmp = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 347)					this->moveTo(_hx_tmp,(::Std_obj::parseFloat(arr3->__get(1)) + y));
HXDLIN( 347)					goto _hx_goto_64;
            				}
            				/* default */{
HXLINE( 354)					::haxe::Log_obj::trace((str + HX_(" NOT FOUND in aiString",e9,9d,62,e1)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),354,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("aiString",d9,8f,2f,00)));
            				}
            				_hx_goto_64:;
            			}
            		}
            		else {
HXLINE( 358)			int _g = 0;
HXDLIN( 358)			int _g1 = len;
HXDLIN( 358)			while((_g < _g1)){
HXLINE( 358)				_g = (_g + 1);
HXDLIN( 358)				int i = (_g - 1);
HXLINE( 359)				int len2 = arr1->__get(i).StaticCast< ::Array< ::String > >()->length;
HXLINE( 360)				::Array< ::String > arr3 = arr1->__get(i).StaticCast< ::Array< ::String > >();
HXLINE( 361)				::String str = arr3->__get((len2 - 1));
HXLINE( 362)				::String _hx_switch_1 = str;
            				if (  (_hx_switch_1==HX_("C",43,00,00,00)) ){
HXLINE( 368)					Float x1 = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 368)					Float y1 = ((flipY - ::Std_obj::parseFloat(arr3->__get(1))) + y);
HXDLIN( 368)					Float x2 = (::Std_obj::parseFloat(arr3->__get(1)) + x);
HXDLIN( 368)					Float y2 = ((flipY - ::Std_obj::parseFloat(arr3->__get(2))) + y);
HXDLIN( 368)					this->tempArr = ::Array_obj< Float >::__new(0);
HXDLIN( 368)					{
HXLINE( 368)						::Array< Float > p = this->tempArr;
HXDLIN( 368)						Float ax = this->x;
HXDLIN( 368)						Float ay = this->y;
HXDLIN( 368)						Float x3 = (ax - x1);
HXDLIN( 368)						Float y3 = (ay - y1);
HXDLIN( 368)						Float x4 = (x1 - x2);
HXDLIN( 368)						Float y4 = (y1 - y2);
HXDLIN( 368)						Float approxDistance = (::Math_obj::sqrt(((x3 * x3) + (y3 * y3))) + ::Math_obj::sqrt(((x4 * x4) + (y4 * y4))));
HXDLIN( 368)						if ((approxDistance == 0)) {
HXLINE( 368)							approxDistance = ((Float)0.000001);
            						}
HXDLIN( 368)						Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::trilateral3::math::_Algebra::Algebra_Fields__obj::quadStep);
HXDLIN( 368)						int l = p->length;
HXDLIN( 368)						l = (l + 1);
HXDLIN( 368)						p[(l - 1)] = ax;
HXDLIN( 368)						l = (l + 1);
HXDLIN( 368)						p[(l - 1)] = ay;
HXDLIN( 368)						Float t = step;
HXDLIN( 368)						while((t < ((Float)1.))){
HXLINE( 368)							l = (l + 1);
HXDLIN( 368)							Float u = (( (Float)(1) ) - t);
HXDLIN( 368)							p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * x1)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
HXDLIN( 368)							l = (l + 1);
HXDLIN( 368)							Float u1 = (( (Float)(1) ) - t);
HXDLIN( 368)							p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * y1)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
HXDLIN( 368)							t = (t + step);
            						}
HXDLIN( 368)						l = (l + 1);
HXDLIN( 368)						p[(l - 1)] = x2;
HXDLIN( 368)						l = (l + 1);
HXDLIN( 368)						p[(l - 1)] = y2;
            					}
HXDLIN( 368)					{
HXLINE( 368)						::Array< Float > arr = this->tempArr;
HXDLIN( 368)						 ::Dynamic withMove = false;
HXDLIN( 368)						if (::hx::IsNull( withMove )) {
HXLINE( 368)							withMove = true;
            						}
HXDLIN( 368)						int l1 = arr->length;
HXDLIN( 368)						int i = 2;
HXDLIN( 368)						if (( (bool)(withMove) )) {
HXLINE( 368)							this->moveTo(arr->__get(0),arr->__get(1));
            						}
            						else {
HXLINE( 368)							Float x_ = arr->__get(0);
HXDLIN( 368)							Float y_ = arr->__get(1);
HXDLIN( 368)							bool repeat;
HXDLIN( 368)							if ((this->x == x_)) {
HXLINE( 368)								repeat = (this->y == y_);
            							}
            							else {
HXLINE( 368)								repeat = false;
            							}
HXDLIN( 368)							if (!(repeat)) {
HXLINE( 368)								if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 368)									this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            								}
HXDLIN( 368)								if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 368)									this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            								}
HXDLIN( 368)								this->line(x_,y_);
HXDLIN( 368)								int l = this->points->length;
HXDLIN( 368)								::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 368)								int l2 = p->length;
HXDLIN( 368)								p[l2] = x_;
HXDLIN( 368)								p[(l2 + 1)] = y_;
HXDLIN( 368)								{
HXLINE( 368)									 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 368)									if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 368)										d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            									}
HXDLIN( 368)									if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 368)										d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            									}
HXDLIN( 368)									if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 368)										d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            									}
HXDLIN( 368)									if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 368)										d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            									}
            								}
HXDLIN( 368)								this->x = x_;
HXDLIN( 368)								this->y = y_;
            							}
            						}
HXDLIN( 368)						while((i < l1)){
HXLINE( 368)							{
HXLINE( 368)								Float x_ = arr->__get(i);
HXDLIN( 368)								Float y_ = arr->__get((i + 1));
HXDLIN( 368)								bool repeat;
HXDLIN( 368)								if ((this->x == x_)) {
HXLINE( 368)									repeat = (this->y == y_);
            								}
            								else {
HXLINE( 368)									repeat = false;
            								}
HXDLIN( 368)								if (!(repeat)) {
HXLINE( 368)									if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 368)										this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            									}
HXDLIN( 368)									if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 368)										this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            									}
HXDLIN( 368)									this->line(x_,y_);
HXDLIN( 368)									int l = this->points->length;
HXDLIN( 368)									::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 368)									int l2 = p->length;
HXDLIN( 368)									p[l2] = x_;
HXDLIN( 368)									p[(l2 + 1)] = y_;
HXDLIN( 368)									{
HXLINE( 368)										 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 368)										if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 368)											d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            										}
HXDLIN( 368)										if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 368)											d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            										}
HXDLIN( 368)										if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 368)											d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            										}
HXDLIN( 368)										if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 368)											d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            										}
            									}
HXDLIN( 368)									this->x = x_;
HXDLIN( 368)									this->y = y_;
            								}
            							}
HXDLIN( 368)							i = (i + 2);
            						}
            					}
HXDLIN( 368)					this->x = x2;
HXDLIN( 368)					this->y = y2;
HXDLIN( 368)					goto _hx_goto_68;
            				}
            				if (  (_hx_switch_1==HX_("L",4c,00,00,00)) ){
HXLINE( 366)					Float x_ = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 366)					Float y_ = ((flipY - ::Std_obj::parseFloat(arr3->__get(1))) + y);
HXDLIN( 366)					bool repeat;
HXDLIN( 366)					if ((this->x == x_)) {
HXLINE( 366)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 366)						repeat = false;
            					}
HXDLIN( 366)					if (!(repeat)) {
HXLINE( 366)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 366)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 366)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 366)							this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 366)						this->line(x_,y_);
HXDLIN( 366)						int l = this->points->length;
HXDLIN( 366)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 366)						int l2 = p->length;
HXDLIN( 366)						p[l2] = x_;
HXDLIN( 366)						p[(l2 + 1)] = y_;
HXDLIN( 366)						{
HXLINE( 366)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 366)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 366)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 366)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 366)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 366)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 366)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 366)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 366)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 366)						this->x = x_;
HXDLIN( 366)						this->y = y_;
            					}
HXDLIN( 366)					goto _hx_goto_68;
            				}
            				if (  (_hx_switch_1==HX_("m",6d,00,00,00)) ){
HXLINE( 364)					Float _hx_tmp = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 364)					this->moveTo(_hx_tmp,((flipY - ::Std_obj::parseFloat(arr3->__get(1))) + y));
HXDLIN( 364)					goto _hx_goto_68;
            				}
            				/* default */{
HXLINE( 371)					::haxe::Log_obj::trace((str + HX_(" NOT FOUND in aiString",e9,9d,62,e1)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),371,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("aiString",d9,8f,2f,00)));
            				}
            				_hx_goto_68:;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Sketch_obj,aiString,(void))

 ::trilateral3::drawing::Sketch Sketch_obj::create( ::Dynamic drawType_, ::Dynamic colorType_,int sketchForm_,::hx::Null< int >  __o_endLine_){
            		int endLine_ = __o_endLine_.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_6351d8d914bc61da_84_create)
HXLINE(  86)		 ::trilateral3::drawing::Pen pen =  ::trilateral3::drawing::Pen_obj::__alloc( HX_CTX ,drawType_,colorType_);
HXLINE(  87)		return  ::trilateral3::drawing::Sketch_obj::__alloc( HX_CTX ,pen,sketchForm_,endLine_);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Sketch_obj,create,return )


::hx::ObjectPtr< Sketch_obj > Sketch_obj::__new( ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_) {
	::hx::ObjectPtr< Sketch_obj > __this = new Sketch_obj();
	__this->__construct(pen_,sketchForm_,__o_endLine_);
	return __this;
}

::hx::ObjectPtr< Sketch_obj > Sketch_obj::__alloc(::hx::Ctx *_hx_ctx, ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_) {
	Sketch_obj *__this = (Sketch_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Sketch_obj), true, "trilateral3.drawing.Sketch"));
	*(void **)__this = Sketch_obj::_hx_vtable;
	__this->__construct(pen_,sketchForm_,__o_endLine_);
	return __this;
}

Sketch_obj::Sketch_obj()
{
}

void Sketch_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Sketch);
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(widthFunction,"widthFunction");
	HX_MARK_MEMBER_NAME(colourFunction,"colourFunction");
	HX_MARK_MEMBER_NAME(tempArr,"tempArr");
	HX_MARK_MEMBER_NAME(contour,"contour");
	HX_MARK_MEMBER_NAME(pen,"pen");
	HX_MARK_MEMBER_NAME(endLine,"endLine");
	HX_MARK_MEMBER_NAME(sketchForm,"sketchForm");
	HX_MARK_MEMBER_NAME(points,"points");
	HX_MARK_MEMBER_NAME(pointsClock,"pointsClock");
	HX_MARK_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_MARK_MEMBER_NAME(dim,"dim");
	HX_MARK_MEMBER_NAME(line,"line");
	HX_MARK_END_CLASS();
}

void Sketch_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(widthFunction,"widthFunction");
	HX_VISIT_MEMBER_NAME(colourFunction,"colourFunction");
	HX_VISIT_MEMBER_NAME(tempArr,"tempArr");
	HX_VISIT_MEMBER_NAME(contour,"contour");
	HX_VISIT_MEMBER_NAME(pen,"pen");
	HX_VISIT_MEMBER_NAME(endLine,"endLine");
	HX_VISIT_MEMBER_NAME(sketchForm,"sketchForm");
	HX_VISIT_MEMBER_NAME(points,"points");
	HX_VISIT_MEMBER_NAME(pointsClock,"pointsClock");
	HX_VISIT_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_VISIT_MEMBER_NAME(dim,"dim");
	HX_VISIT_MEMBER_NAME(line,"line");
}

::hx::Val Sketch_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return ::hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return ::hx::Val( y ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { return ::hx::Val( pen ); }
		if (HX_FIELD_EQ(inName,"dim") ) { return ::hx::Val( dim ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { return ::hx::Val( line ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		if (HX_FIELD_EQ(inName,"reset") ) { return ::hx::Val( reset_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { return ::hx::Val( points ); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return ::hx::Val( moveTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"lineTo") ) { return ::hx::Val( lineTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"quadTo") ) { return ::hx::Val( quadTo_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tempArr") ) { return ::hx::Val( tempArr ); }
		if (HX_FIELD_EQ(inName,"contour") ) { return ::hx::Val( contour ); }
		if (HX_FIELD_EQ(inName,"endLine") ) { return ::hx::Val( endLine ); }
		if (HX_FIELD_EQ(inName,"initDim") ) { return ::hx::Val( initDim_dyn() ); }
		if (HX_FIELD_EQ(inName,"curveTo") ) { return ::hx::Val( curveTo_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"baseLine") ) { return ::hx::Val( baseLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"fineLine") ) { return ::hx::Val( fineLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"getEdges") ) { return ::hx::Val( getEdges_dyn() ); }
		if (HX_FIELD_EQ(inName,"quadThru") ) { return ::hx::Val( quadThru_dyn() ); }
		if (HX_FIELD_EQ(inName,"aiString") ) { return ::hx::Val( aiString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"crudeLine") ) { return ::hx::Val( crudeLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateDim") ) { return ::hx::Val( updateDim_dyn() ); }
		if (HX_FIELD_EQ(inName,"lastClock") ) { return ::hx::Val( lastClock_dyn() ); }
		if (HX_FIELD_EQ(inName,"plotCoord") ) { return ::hx::Val( plotCoord_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sketchForm") ) { return ::hx::Val( sketchForm ); }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { return ::hx::Val( pointsAnti ); }
		if (HX_FIELD_EQ(inName,"tracerLine") ) { return ::hx::Val( tracerLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"mediumLine") ) { return ::hx::Val( mediumLine_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { return ::hx::Val( pointsClock ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fillOnlyLine") ) { return ::hx::Val( fillOnlyLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"roundEndLine") ) { return ::hx::Val( roundEndLine_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"widthFunction") ) { return ::hx::Val( widthFunction ); }
		if (HX_FIELD_EQ(inName,"pointsRewound") ) { return ::hx::Val( pointsRewound_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colourFunction") ) { return ::hx::Val( colourFunction ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fineOverlapLine") ) { return ::hx::Val( fineOverlapLine_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"mediumOverlapLine") ) { return ::hx::Val( mediumOverlapLine_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"pointsNoEndOverlap") ) { return ::hx::Val( pointsNoEndOverlap_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Sketch_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { outValue = create_dyn(); return true; }
	}
	return false;
}

::hx::Val Sketch_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { pen=inValue.Cast<  ::trilateral3::drawing::Pen >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dim") ) { dim=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { line=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { points=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tempArr") ) { tempArr=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"contour") ) { contour=inValue.Cast<  ::trilateral3::drawing::Contour >(); return inValue; }
		if (HX_FIELD_EQ(inName,"endLine") ) { endLine=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sketchForm") ) { sketchForm=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { pointsAnti=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { pointsClock=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"widthFunction") ) { widthFunction=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colourFunction") ) { colourFunction=inValue.Cast<  ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Sketch_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("tempArr",ad,17,ac,46));
	outFields->push(HX_("contour",da,29,7f,19));
	outFields->push(HX_("pen",d9,54,55,00));
	outFields->push(HX_("endLine",6f,d1,d7,29));
	outFields->push(HX_("sketchForm",d0,2c,96,9a));
	outFields->push(HX_("points",23,12,2e,f7));
	outFields->push(HX_("pointsClock",ab,c8,9e,88));
	outFields->push(HX_("pointsAnti",65,1b,f0,ae));
	outFields->push(HX_("dim",48,3d,4c,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Sketch_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(Sketch_obj,x),HX_("x",78,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Sketch_obj,y),HX_("y",79,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Sketch_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,widthFunction),HX_("widthFunction",3e,93,b5,7c)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,colourFunction),HX_("colourFunction",84,5b,3e,e4)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(Sketch_obj,tempArr),HX_("tempArr",ad,17,ac,46)},
	{::hx::fsObject /*  ::trilateral3::drawing::Contour */ ,(int)offsetof(Sketch_obj,contour),HX_("contour",da,29,7f,19)},
	{::hx::fsObject /*  ::trilateral3::drawing::Pen */ ,(int)offsetof(Sketch_obj,pen),HX_("pen",d9,54,55,00)},
	{::hx::fsInt,(int)offsetof(Sketch_obj,endLine),HX_("endLine",6f,d1,d7,29)},
	{::hx::fsInt,(int)offsetof(Sketch_obj,sketchForm),HX_("sketchForm",d0,2c,96,9a)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,points),HX_("points",23,12,2e,f7)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,pointsClock),HX_("pointsClock",ab,c8,9e,88)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,pointsAnti),HX_("pointsAnti",65,1b,f0,ae)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,dim),HX_("dim",48,3d,4c,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,line),HX_("line",f4,17,b3,47)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Sketch_obj_sStaticStorageInfo = 0;
#endif

static ::String Sketch_obj_sMemberFields[] = {
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("width",06,b6,62,ca),
	HX_("widthFunction",3e,93,b5,7c),
	HX_("colourFunction",84,5b,3e,e4),
	HX_("tempArr",ad,17,ac,46),
	HX_("contour",da,29,7f,19),
	HX_("pen",d9,54,55,00),
	HX_("endLine",6f,d1,d7,29),
	HX_("sketchForm",d0,2c,96,9a),
	HX_("points",23,12,2e,f7),
	HX_("pointsClock",ab,c8,9e,88),
	HX_("pointsAnti",65,1b,f0,ae),
	HX_("dim",48,3d,4c,00),
	HX_("tracerLine",e1,14,6f,0a),
	HX_("fillOnlyLine",23,35,20,bc),
	HX_("baseLine",a5,08,01,fc),
	HX_("crudeLine",7b,a3,d6,62),
	HX_("roundEndLine",c1,c6,50,fc),
	HX_("mediumLine",09,77,f0,3b),
	HX_("mediumOverlapLine",a6,34,72,5e),
	HX_("fineLine",4e,b9,ad,2d),
	HX_("fineOverlapLine",01,f5,59,3a),
	HX_("line",f4,17,b3,47),
	HX_("reset",cf,49,c8,e6),
	HX_("pointsNoEndOverlap",50,8f,f9,44),
	HX_("pointsRewound",5d,22,d0,4a),
	HX_("initDim",18,04,83,cb),
	HX_("updateDim",bf,1a,d9,82),
	HX_("moveTo",ec,d2,ac,cc),
	HX_("lastClock",98,37,10,95),
	HX_("getEdges",20,7d,b7,c9),
	HX_("lineTo",8f,46,a0,ec),
	HX_("quadTo",22,82,9f,cc),
	HX_("quadThru",9e,e2,18,d5),
	HX_("curveTo",0a,60,88,ce),
	HX_("plotCoord",d4,98,a6,b1),
	HX_("aiString",d9,8f,2f,00),
	::String(null()) };

::hx::Class Sketch_obj::__mClass;

static ::String Sketch_obj_sStaticFields[] = {
	HX_("create",fc,66,0f,7c),
	::String(null())
};

void Sketch_obj::__register()
{
	Sketch_obj _hx_dummy;
	Sketch_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("trilateral3.drawing.Sketch",23,f7,00,b3);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Sketch_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Sketch_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Sketch_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Sketch_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Sketch_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Sketch_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace trilateral3
} // end namespace drawing
